// -*- mode:c++ -*-

// Copyright (c) 2007-2008 The Florida State University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Stephen Hines

////////////////////////////////////////////////////////////////////
//
// Predicated Instruction Execution
//

let {{
    predicateTest = 'testPredicate(CondCodes, condCode)'
}};

def template PredOpExecute {{
    Fault %(class_name)s::execute(%(CPU_exec_context)s *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        %(op_decl)s;
        %(op_rd)s;

        if (%(predicate_test)s)
        {
            %(code)s;
            if (fault == NoFault)
            {
                %(op_wb)s;
            }
        }

        return fault;
    }
}};

def template DataDecode {{
    if (machInst.opcode4 == 0) {
        if (machInst.sField == 0)
            return new %(class_name)sImm(machInst);
        else
            return new %(class_name)sImmCc(machInst);
    } else {
        if (machInst.sField == 0)
            return new %(class_name)s(machInst);
        else
            return new %(class_name)sCc(machInst);
    }
}};

def template DataImmDecode {{
    if (machInst.sField == 0)
        return new %(class_name)s(machInst);
    else
        return new %(class_name)sCc(machInst);
}};

let {{

    calcCcCode = '''
        uint16_t _ic, _iv, _iz, _in;

        _in = (resTemp >> 31) & 1;
        _iz = (resTemp == 0);
        _iv = %(ivValue)s & 1;
        _ic = %(icValue)s & 1;

        CondCodes =  _in << 31 | _iz << 30 | _ic << 29 | _iv << 28 |
            (CondCodes & 0x0FFFFFFF);

        DPRINTF(Arm, "in = %%d\\n", _in);
        DPRINTF(Arm, "iz = %%d\\n", _iz);
        DPRINTF(Arm, "ic = %%d\\n", _ic);
        DPRINTF(Arm, "iv = %%d\\n", _iv);
        '''

}};

let {{
    def getCcCode(flagtype):
        icReg = icImm = iv = ''
        if flagtype == "none":
            icReg = icImm = 'CondCodes<29:>'
            iv = 'CondCodes<28:>'
        elif flagtype == "add":
            icReg = icImm = 'findCarry(32, resTemp, Rn, op2)'
            iv = 'findOverflow(32, resTemp, Rn, op2)'
        elif flagtype == "sub":
            icReg = icImm ='findCarry(32, resTemp, Rn, ~op2)'
            iv = 'findOverflow(32, resTemp, Rn, ~op2)'
        elif flagtype == "rsb":
            icReg = icImm = 'findCarry(32, resTemp, op2, ~Rn)'
            iv = 'findOverflow(32, resTemp, op2, ~Rn)'
        else:
            icReg = 'shift_carry_rs(Rm, Rs, shift, CondCodes<29:>)'
            icImm = 'shift_carry_imm(Rm, shift_size, shift, CondCodes<29:>)'
            iv = 'CondCodes<28:>'
        return (calcCcCode % {"icValue" : icReg, "ivValue" : iv},
                calcCcCode % {"icValue" : icImm, "ivValue" : iv})

    def getImmCcCode(flagtype):
        ivValue = icValue = ''
        if flagtype == "none":
            icValue = 'CondCodes<29:>'
            ivValue = 'CondCodes<28:>'
        elif flagtype == "add":
            icValue = 'findCarry(32, resTemp, Rn, rotated_imm)'
            ivValue = 'findOverflow(32, resTemp, Rn, rotated_imm)'
        elif flagtype == "sub":
            icValue = 'findCarry(32, resTemp, Rn, ~rotated_imm)'
            ivValue = 'findOverflow(32, resTemp, Rn, ~rotated_imm)'
        elif flagtype == "rsb":
            icValue = 'findCarry(32, resTemp, rotated_imm, ~Rn)'
            ivValue = 'findOverflow(32, resTemp, rotated_imm, ~Rn)'
        else:
            icValue = '(rotate ? rotated_carry:CondCodes<29:>)'
            ivValue = 'CondCodes<28:>'
        return calcCcCode % vars()
}};

def format DataOp(code, flagtype = logic) {{
    (regCcCode, immCcCode) = getCcCode(flagtype)
    regCode = '''uint32_t op2 = shift_rm_rs(Rm, Rs,
                                            shift, CondCodes<29:0>);
                 op2 = op2;''' + code
    immCode = '''uint32_t op2 = shift_rm_imm(Rm, shift_size,
                                             shift, CondCodes<29:0>);
                 op2 = op2;''' + code
    regIop = InstObjParams(name, Name, 'PredIntOp',
                           {"code": regCode,
                            "predicate_test": predicateTest})
    immIop = InstObjParams(name, Name + "Imm", 'PredIntOp',
                           {"code": immCode,
                            "predicate_test": predicateTest})
    regCcIop = InstObjParams(name, Name + "Cc", 'PredIntOp',
                             {"code": regCode + regCcCode,
                              "predicate_test": predicateTest})
    immCcIop = InstObjParams(name, Name + "ImmCc", 'PredIntOp',
                             {"code": immCode + immCcCode,
                              "predicate_test": predicateTest})
    header_output = BasicDeclare.subst(regIop) + \
                    BasicDeclare.subst(immIop) + \
                    BasicDeclare.subst(regCcIop) + \
                    BasicDeclare.subst(immCcIop)
    decoder_output = BasicConstructor.subst(regIop) + \
                     BasicConstructor.subst(immIop) + \
                     BasicConstructor.subst(regCcIop) + \
                     BasicConstructor.subst(immCcIop)
    exec_output = PredOpExecute.subst(regIop) + \
                  PredOpExecute.subst(immIop) + \
                  PredOpExecute.subst(regCcIop) + \
                  PredOpExecute.subst(immCcIop)
    decode_block = DataDecode.subst(regIop)
}};

def format DataImmOp(code, flagtype = logic) {{
    code += "resTemp = resTemp;"
    iop = InstObjParams(name, Name, 'PredImmOp',
                        {"code": code,
                         "predicate_test": predicateTest})
    ccIop = InstObjParams(name, Name + "Cc", 'PredImmOp',
                          {"code": code + getImmCcCode(flagtype),
                           "predicate_test": predicateTest})
    header_output = BasicDeclare.subst(iop) + \
                    BasicDeclare.subst(ccIop)
    decoder_output = BasicConstructor.subst(iop) + \
                     BasicConstructor.subst(ccIop)
    exec_output = PredOpExecute.subst(iop) + \
                  PredOpExecute.subst(ccIop)
    decode_block = DataImmDecode.subst(iop)
}};

def format PredOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'PredOp',
                        {"code": code,
                         "predicate_test": predicateTest},
                        opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = PredOpExecute.subst(iop)
}};

def format PredImmOp(code, *opt_flags) {{
    iop = InstObjParams(name, Name, 'PredImmOp',
                        {"code": code,
                         "predicate_test": predicateTest},
                        opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = PredOpExecute.subst(iop)
}};

def format PredImmOpCc(code, icValue, ivValue, *opt_flags) {{
    ccCode = calcCcCode % vars()
    code += ccCode;
    iop = InstObjParams(name, Name, 'PredImmOp',
                        {"code": code,
                         "cc_code": ccCode,
                         "predicate_test": predicateTest},
                        opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = PredOpExecute.subst(iop)
}};

def format PredIntOp(code, *opt_flags) {{
    new_code = ArmGenericCodeSubs(code)
    iop = InstObjParams(name, Name, 'PredIntOp',
                        {"code": new_code,
                         "predicate_test": predicateTest},
                        opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = PredOpExecute.subst(iop)
}};

def format PredIntOpCc(code, icValue, ivValue, *opt_flags) {{
    ccCode = calcCcCode % vars()
    code += ccCode;
    new_code = ArmGenericCodeSubs(code)
    iop = InstObjParams(name, Name, 'PredIntOp',
                        {"code": new_code,
                         "cc_code": ccCode,
                         "predicate_test": predicateTest},
                        opt_flags)
    header_output = BasicDeclare.subst(iop)
    decoder_output = BasicConstructor.subst(iop)
    decode_block = BasicDecode.subst(iop)
    exec_output = PredOpExecute.subst(iop)
}};


// Copyright (c) 2007-2008 The Hewlett-Packard Development Company
// All rights reserved.
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//////////////////////////////////////////////////////////////////////////
//
// RegOp Microop templates
//
//////////////////////////////////////////////////////////////////////////

def template MicroRegOpExecute {{
    Fault
    %(class_name)s::execute(ExecContext *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        DPRINTF(X86, "The data size is %d\n", dataSize);
        %(op_decl)s;
        %(op_rd)s;

        [[maybe_unused]] RegVal result;

        if (%(cond_check)s) {
            %(code)s;
            %(flag_code)s;
        } else {
            %(else_code)s;
        }

        //Write the resulting state to the execution context
        if (fault == NoFault) {
            %(op_wb)s;
        }
        return fault;
    }
}};

def template MicroRegOpDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      private:
        %(reg_idx_arr_decl)s;

      public:
        template <typename ...Args>
        %(class_name)s(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            %(base_class)s(mach_inst, "%(mnemonic)s", inst_mnem, set_flags,
                    %(op_class)s, { args... }, data_size, _ext)
        {
            %(set_reg_idx_arr)s;
            %(constructor)s;
            %(cond_control_flag_init)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const override;
    };
}};

def template MicroRegOpBranchDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      private:
        %(reg_idx_arr_decl)s;

      public:
        template <typename ...Args>
        %(class_name)s(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            %(base_class)s(mach_inst, "%(mnemonic)s", inst_mnem, set_flags,
                    %(op_class)s, { args... }, data_size, _ext)
        {
            %(set_reg_idx_arr)s;
            %(constructor)s;
            %(cond_control_flag_init)s;
        }

        Fault execute(ExecContext *, Trace::InstRecord *) const override;

        std::unique_ptr<PCStateBase> branchTarget(
                const PCStateBase &branchPC) const override;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
    };
}};

def template MicroRegOpBranchTarget {{
    std::unique_ptr<PCStateBase>
    %(class_name)s::branchTarget(const PCStateBase &branch_pc) const
    {
        PCStateBase *pcs = branch_pc.clone();
        DPRINTF(X86, "branchTarget PC info: %s, Immediate (imm8): %lx\n",
                *pcs, (int8_t)imm8);
        auto &xpc = pcs->as<PCState>();
        xpc.npc(xpc.npc() + (int8_t)imm8);
        xpc.uEnd();
        return std::unique_ptr<PCStateBase>{pcs};
    }
}};

output header {{
    enum SegmentSelectorCheck
    {
        SegNoCheck,
        SegCSCheck,
        SegCallGateCheck,
        SegIntGateCheck,
        SegSoftIntGateCheck,
        SegSSCheck,
        SegIretCheck,
        SegIntCSCheck,
        SegTRCheck,
        SegTSSCheck,
        SegInGDTCheck,
        SegLDTCheck
    };

    enum LongModeDescriptorType
    {
        LDT64 = 2,
        AvailableTSS64 = 9,
        BusyTSS64 = 0xb,
        CallGate64 = 0xc,
        IntGate64 = 0xe,
        TrapGate64 = 0xf
    };
}};

let {{
    # Make these empty strings so that concatenating onto
    # them will always work.
    header_output = ""
    decoder_output = ""
    exec_output = ""

    branchTemplates = (
            MicroRegOpBranchDeclare,
            MicroRegOpBranchTarget,
            MicroRegOpExecute)

    normalTemplates = (
            MicroRegOpDeclare,
            None,
            MicroRegOpExecute)


    class RegOpMeta(type):
        def buildCppClasses(self, name, Name, suffix, code, big_code, \
                flag_code, cond_check, else_code, cond_control_flag_init,
                op_class, operand_types):

            # Globals to stick the output in
            global header_output
            global decoder_output
            global exec_output

            # Stick all the code together so it can be searched at once
            allCode = "|".join((code, flag_code, cond_check, else_code,
                                cond_control_flag_init))
            allBigCode = "|".join((big_code, flag_code, cond_check, else_code,
                                   cond_control_flag_init))

            # If op2 is used anywhere, make register and immediate versions
            # of this code.
            matcher = re.compile(
                    r"(?<!\w)(?P<prefix>s?)op2(?P<typeQual>_[^\W_]+)?")
            match = matcher.search(allCode + allBigCode)

            imm_operand_types = list([op if not op.isDual() else op.ImmType for
                                      op in operand_types])
            operand_types = list([op if not op.isDual() else op.RegType for
                                  op in operand_types])

            if match:
                typeQual = ""
                if match.group("typeQual"):
                    typeQual = match.group("typeQual")
                src2_name = "%sPSrcReg2%s" % (match.group("prefix").upper(),
                        typeQual)
                self.buildCppClasses(name, Name, suffix,
                        matcher.sub(src2_name, code),
                        matcher.sub(src2_name, big_code),
                        matcher.sub(src2_name, flag_code),
                        matcher.sub(src2_name, cond_check),
                        matcher.sub(src2_name, else_code),
                        matcher.sub(src2_name, cond_control_flag_init),
                        op_class, operand_types)
                imm_name = '(int8_t)imm8' if match.group("prefix") else 'imm8'
                self.buildCppClasses(name + "i", Name, suffix + "Imm",
                        matcher.sub(imm_name, code),
                        matcher.sub(imm_name, big_code),
                        matcher.sub(imm_name, flag_code),
                        matcher.sub(imm_name, cond_check),
                        matcher.sub(imm_name, else_code),
                        matcher.sub(imm_name, cond_control_flag_init),
                        op_class, imm_operand_types)
                return

            # If there's something optional to do with flags, generate
            # a version without it and fix up this version to use it.
            if flag_code != "" or cond_check != "true":
                self.buildCppClasses(name, Name, suffix,
                        code, big_code, "", "true", else_code,
                        "flags[IsUncondControl] = flags[IsControl];", op_class,
                        operand_types)
                suffix = "Flags" + suffix

            cxx_classes = list([op.cxx_class() for op in operand_types])
            base = "X86ISA::RegOpT<" + ', '.join(cxx_classes) + '>'

            if re.search('imm8', allCode) and re.search('NRIP', allCode):
                templates = branchTemplates
            else:
                templates = normalTemplates

            # Get everything ready for the substitution
            iops = [InstObjParams(name, Name + suffix, base,
                    {"code" : code,
                     "flag_code" : flag_code,
                     "cond_check" : cond_check,
                     "else_code" : else_code,
                     "cond_control_flag_init" : cond_control_flag_init,
                     "op_class" : op_class})]
            if big_code != "":
                iops += [InstObjParams(name, Name + suffix + "Big", base,
                         {"code" : big_code,
                          "flag_code" : flag_code,
                          "cond_check" : cond_check,
                          "else_code" : else_code,
                          "cond_control_flag_init" : cond_control_flag_init,
                          "op_class" : op_class})]

            # Generate the actual code (finally!)
            for iop in iops:
                header_output += templates[0].subst(iop)
                if templates[1]:
                    decoder_output += templates[1].subst(iop)
                exec_output += templates[2].subst(iop)


        def __new__(mcls, Name, bases, dict):
            abstract = False
            name = Name.lower()
            if "abstract" in dict:
                abstract = dict['abstract']
                del dict['abstract']

            cls = super().__new__(mcls, Name, bases, dict)
            if abstract:
                return cls

            cls.className = Name
            cls.base_mnemonic = name
            code = cls.code
            big_code = cls.big_code
            flag_code = cls.flag_code
            cond_check = cls.cond_check
            else_code = cls.else_code
            cond_control_flag_init = cls.cond_control_flag_init
            op_class = cls.op_class
            operand_types = cls.operand_types

            # Set up the C++ classes
            mcls.buildCppClasses(cls, name, Name, "", code, big_code,
                    flag_code, cond_check, else_code,
                    cond_control_flag_init, op_class, operand_types)

            # Hook into the microassembler dict
            global microopClasses
            microopClasses[name] = cls

            allCode = "|".join((code, flag_code, cond_check, else_code,
                                cond_control_flag_init))

            # If op2 is used anywhere, make register and immediate versions
            # of this code.
            matcher = re.compile(r"op2(?P<typeQual>_[^\W_]+)?")
            if matcher.search(allCode):
                microopClasses[name + 'i'] = cls

            return cls


    class RegOp(X86Microop, metaclass=RegOpMeta):
        # This class itself doesn't act as a microop
        abstract = True

        # Default template parameter values
        big_code = ""
        flag_code = ""
        cond_check = "true"
        else_code = ";"
        cond_control_flag_init = ""
        op_class = "IntAluOp"

        def __init__(self, *ops, flags=None, dataSize="env.dataSize"):
            self.ops = list(map(str, ops))
            self.flags = flags
            self.dataSize = dataSize
            if flags is None:
                self.ext = 0
            else:
                if not isinstance(flags, (list, tuple)):
                    raise Exception("flags must be a list or tuple of flags")
                self.ext = " | ".join(flags)
                self.className += "Flags"

        def getAllocator(self, microFlags):
            is_imm = (self.mnemonic == self.base_mnemonic + 'i')
            def resolve_dual(t):
                if t.isDual():
                    if is_imm:
                        return t.ImmType
                    else:
                        return t.RegType
                else:
                    return t
            operand_types = map(resolve_dual, self.operand_types)
            op_iter = iter(self.ops)
            ops = list([Type(op_iter).ctor_args() for Type in operand_types])
            op_args = ', '.join(ops)
            if self.big_code != "":
                className = self.className
                if is_imm:
                    className += "Imm"
                allocString = '''
                    (%(dataSize)s >= 4) ?
                        (StaticInstPtr)(new %(class_name)sBig(machInst,
                            macrocodeBlock, %(flags)s, %(dataSize)s, %(ext)s,
                            %(op_args)s)) :
                        (StaticInstPtr)(new %(class_name)s(machInst,
                            macrocodeBlock, %(flags)s, %(dataSize)s, %(ext)s,
                            %(op_args)s))
                    '''
                allocator = allocString % {
                    "class_name" : className,
                    "flags" : self.microFlagsText(microFlags),
                    "op_args" : op_args,
                    "dataSize" : self.dataSize,
                    "ext" : self.ext}
                return allocator
            else:
                className = self.className
                if is_imm:
                    className += "Imm"
                allocator = '''new %(class_name)s(machInst, macrocodeBlock,
                        %(flags)s, %(dataSize)s, %(ext)s, %(op_args)s)''' % {
                    "class_name" : className,
                    "flags" : self.microFlagsText(microFlags),
                    "op_args" : op_args,
                    "dataSize" : self.dataSize,
                    "ext" : self.ext}
                return allocator

    class BasicRegOp(RegOp):
        operand_types = (FoldedDestOp, FoldedSrc1Op, Op2)
        abstract = True

        def __init__(self, dest, src1, src2, flags=None,
                dataSize="env.dataSize"):
            super().__init__(dest, src1, src2, flags=flags, dataSize=dataSize)

    class LogicRegOp(BasicRegOp):
        abstract = True
        flag_code = '''
            //Don't have genFlags handle the OF or CF bits
            uint64_t mask = CFBit | ECFBit | OFBit;
            uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                    PredezfBit, ext & ~mask, result, PSrcReg1, op2);
            PredezfBit = newFlags & EZFBit;
            PreddfBit = newFlags & DFBit;
            PredccFlagBits = newFlags & CcFlagMask;

            //If a logic microop wants to set these, it wants to set them to 0.
            PredcfofBits = PredcfofBits & ~((CFBit | OFBit) & ext);
            PredecfBit = PredecfBit & ~(ECFBit & ext);
        '''

    class FlagRegOp(BasicRegOp):
        abstract = True
        flag_code = '''
            uint64_t newFlags = genFlags(PredccFlagBits | PredcfofBits |
                                    PreddfBit | PredecfBit | PredezfBit,
                                    ext, result, PSrcReg1, op2);

            PredcfofBits = newFlags & CfofMask;
            PredecfBit = newFlags & ECFBit;
            PredezfBit = newFlags & EZFBit;
            PreddfBit = newFlags & DFBit;
            PredccFlagBits = newFlags & CcFlagMask;
        '''

    class SubRegOp(BasicRegOp):
        abstract = True
        flag_code = '''
            uint64_t newFlags = genFlags(PredccFlagBits | PredcfofBits |
                                         PreddfBit | PredecfBit | PredezfBit,
                                         ext, result, PSrcReg1, ~op2, true);

            PredcfofBits = newFlags & CfofMask;
            PredecfBit = newFlags & ECFBit;
            PredezfBit = newFlags & EZFBit;
            PreddfBit = newFlags & DFBit;
            PredccFlagBits = newFlags & CcFlagMask;
        '''

    class CondRegOp(RegOp):
        abstract = True
        cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | ecfBit | \
                                     ezfBit, ext)"
        cond_control_flag_init = "flags[IsCondControl] = flags[IsControl];"

    class RdRegOp(RegOp):
        operand_types = (FoldedDestOp, FoldedSrc1Op)
        abstract = True
        def __init__(self, dest, src1=None, dataSize="env.dataSize"):
            if not src1:
                src1 = dest
            super().__init__(dest, src1, dataSize=dataSize)

    class WrRegOp(RegOp):
        operand_types = (FoldedSrc1Op, Op2)

        abstract = True
        def __init__(self, src1, src2, flags=None, dataSize="env.dataSize"):
            super().__init__(src1, src2, flags=flags, dataSize=dataSize)

    class Add(FlagRegOp):
        code = '''
            result = PSrcReg1 + op2;
            DestReg = merge(DestReg, dest, result, dataSize);
        '''
        big_code = 'DestReg = result = (PSrcReg1 + op2) & mask(dataSize * 8);'

    class Or(LogicRegOp):
        code = '''
            result = PSrcReg1 | op2;
            DestReg = merge(DestReg, dest, result, dataSize);
        '''
        big_code = 'DestReg = result = (PSrcReg1 | op2) & mask(dataSize * 8);'

    class Adc(FlagRegOp):
        code = '''
            CCFlagBits flags = cfofBits;
            result = PSrcReg1 + op2 + flags.cf;
            DestReg = merge(DestReg, dest, result, dataSize);
            '''
        big_code = '''
            CCFlagBits flags = cfofBits;
            DestReg = result =
                (PSrcReg1 + op2 + flags.cf) & mask(dataSize * 8);
            '''

    class Sbb(SubRegOp):
        code = '''
            CCFlagBits flags = cfofBits;
            result = PSrcReg1 - op2 - flags.cf;
            DestReg = merge(DestReg, dest, result, dataSize);
            '''
        big_code = '''
            CCFlagBits flags = cfofBits;
            DestReg = result =
                (PSrcReg1 - op2 - flags.cf) & mask(dataSize * 8);
            '''

    class And(LogicRegOp):
        code = '''
            result = PSrcReg1 & op2;
            DestReg = merge(DestReg, dest, result, dataSize)
        '''
        big_code = 'DestReg = result = (PSrcReg1 & op2) & mask(dataSize * 8)'

    class Sub(SubRegOp):
        code = '''
            result = PSrcReg1 - op2;
            DestReg = merge(DestReg, dest, result, dataSize)
        '''
        big_code = 'DestReg = result = (PSrcReg1 - op2) & mask(dataSize * 8)'

    class Xor(LogicRegOp):
        code = '''
            result = PSrcReg1 ^ op2;
            DestReg = merge(DestReg, dest, result, dataSize)
        '''
        big_code = 'DestReg = result = (PSrcReg1 ^ op2) & mask(dataSize * 8)'

    class Mul1s(WrRegOp):
        op_class = 'IntMultOp'
        code = '''
            int64_t hi, low;
            switch (dataSize) {
              case 8:
                std::tie(hi, low) = mulSigned<int64_t>(PSrcReg1, op2);
                break;
              case 4:
                std::tie(hi, low) = mulSigned<int32_t>(PSrcReg1, op2);
                break;
              case 2:
                std::tie(hi, low) = mulSigned<int16_t>(PSrcReg1, op2);
                break;
              case 1:
                std::tie(hi, low) = mulSigned<int8_t>(PSrcReg1, op2);
                break;
              default:
                panic("Unrecognized data size %d.", dataSize);
            }
            ProdHi = hi;
            ProdLow = low;
            '''
        flag_code = '''
            if ((-ProdHi & mask(dataSize * 8)) !=
                    bits(ProdLow, dataSize * 8 - 1)) {
                PredcfofBits = PredcfofBits | (ext & (CFBit | OFBit));
                PredecfBit = PredecfBit | (ext & ECFBit);
            } else {
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);
            }
        '''

    class Mul1u(WrRegOp):
        op_class = 'IntMultOp'

        code = '''
            uint64_t hi, low;
            switch (dataSize) {
              case 8:
                std::tie(hi, low) = mulUnsigned<uint64_t>(PSrcReg1, op2);
                break;
              case 4:
                std::tie(hi, low) = mulUnsigned<uint32_t>(PSrcReg1, op2);
                break;
              case 2:
                std::tie(hi, low) = mulUnsigned<uint16_t>(PSrcReg1, op2);
                break;
              case 1:
                std::tie(hi, low) = mulUnsigned<uint8_t>(PSrcReg1, op2);
                break;
              default:
                panic("Unrecognized data size %d.", dataSize);
            }
            ProdHi = hi;
            ProdLow = low;
            '''
        flag_code = '''
            if (ProdHi) {
                PredcfofBits = PredcfofBits | (ext & (CFBit | OFBit));
                PredecfBit = PredecfBit | (ext & ECFBit);
            } else {
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);
            }
        '''

    class Mulel(RdRegOp):
        code = 'DestReg = merge(SrcReg1, dest, ProdLow, dataSize);'
        big_code = 'DestReg = ProdLow & mask(dataSize * 8);'

    class Muleh(RdRegOp):
        def __init__(self, dest, src1=None, flags=None,
                dataSize="env.dataSize"):
            if not src1:
                src1 = dest
            super().__init__(dest, src1, dataSize=dataSize)
        code = 'DestReg = merge(SrcReg1, dest, ProdHi, dataSize);'
        big_code = 'DestReg = ProdHi & mask(dataSize * 8);'

    # One or two bit divide
    class Div1(WrRegOp):
        op_class = 'IntDivOp'

        code = '''
            //These are temporaries so that modifying them later won't make
            //the ISA parser think they're also sources.
            uint64_t quotient = 0;
            uint64_t remainder = PSrcReg1;
            //Similarly, this is a temporary so changing it doesn't make it
            //a source.
            uint64_t divisor = op2;
            //This is a temporary just for consistency and clarity.
            uint64_t dividend = remainder;
            //Do the division.
            if (divisor == 0) {
                fault = std::make_shared<DivideError>();
            } else {
                divideStep(dividend, divisor, quotient, remainder);
                //Record the final results.
                Remainder = remainder;
                Quotient = quotient;
                Divisor = divisor;
            }
            '''

    # Step divide
    class Div2(BasicRegOp):
        op_class = 'IntDivOp'

        divCode = '''
            uint64_t dividend = Remainder;
            uint64_t divisor = Divisor;
            uint64_t quotient = Quotient;
            uint64_t remainder = dividend;
            int remaining = op2;
            //If we overshot, do nothing. This lets us unrool division loops a
            //little.
            if (divisor == 0) {
                fault = std::make_shared<DivideError>();
            } else if (remaining) {
                if (divisor & (1ULL << 63)) {
                    while (remaining && !(dividend & (1ULL << 63))) {
                        dividend = (dividend << 1) |
                            bits(SrcReg1, remaining - 1);
                        quotient <<= 1;
                        remaining--;
                    }
                    if (dividend & (1ULL << 63)) {
                        bool highBit = false;
                        if (dividend < divisor && remaining) {
                            highBit = true;
                            dividend = (dividend << 1) |
                                bits(SrcReg1, remaining - 1);
                            quotient <<= 1;
                            remaining--;
                        }
                        if (highBit || divisor <= dividend) {
                            quotient++;
                            dividend -= divisor;
                        }
                    }
                    remainder = dividend;
                } else {
                    //Shift in bits from the low order portion of the dividend
                    while (dividend < divisor && remaining) {
                        dividend = (dividend << 1) |
                            bits(SrcReg1, remaining - 1);
                        quotient <<= 1;
                        remaining--;
                    }
                    remainder = dividend;
                    //Do the division.
                    divideStep(dividend, divisor, quotient, remainder);
                }
            }
            //Keep track of how many bits there are still to pull in.
            %s
            //Record the final results
            Remainder = remainder;
            Quotient = quotient;
        '''
        code = divCode % "DestReg = merge(DestReg, dest, remaining, dataSize);"
        big_code = divCode % "DestReg = remaining & mask(dataSize * 8);"
        flag_code = '''
            if (remaining == 0)
                PredezfBit = PredezfBit | (ext & EZFBit);
            else
                PredezfBit = PredezfBit & ~(ext & EZFBit);
        '''

    class Divq(RdRegOp):
        code = 'DestReg = merge(SrcReg1, dest, Quotient, dataSize);'
        big_code = 'DestReg = Quotient & mask(dataSize * 8);'

    class Divr(RdRegOp):
        code = 'DestReg = merge(SrcReg1, dest, Remainder, dataSize);'
        big_code = 'DestReg = Remainder & mask(dataSize * 8);'

    class Mov(BasicRegOp, CondRegOp):
        code = 'DestReg = merge(SrcReg1, dest, op2, dataSize)'
        else_code = 'DestReg = DestReg;'

    # Shift instructions

    class Sll(BasicRegOp):
        code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            DestReg = merge(DestReg, dest, PSrcReg1 << shiftAmt, dataSize);
            '''
        big_code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            DestReg = (PSrcReg1 << shiftAmt) & mask(dataSize * 8);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                int CFBits = 0;
                //Figure out if we -would- set the CF bits if requested.
                if (shiftAmt <= dataSize * 8 &&
                        bits(SrcReg1, dataSize * 8 - shiftAmt)) {
                    CFBits = 1;
                }

                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) && CFBits) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) &&
                        (CFBits ^ bits(DestReg, dataSize * 8 - 1))) {
                    PredcfofBits = PredcfofBits | OFBit;
                }

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Srl(BasicRegOp):
        # Because what happens to the bits shift -in- on a right shift
        # is not defined in the C/C++ standard, we have to mask them out
        # to be sure they're zero.
        code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint64_t logicalMask = mask(dataSize * 8 - shiftAmt);
            DestReg = merge(DestReg, dest,
                    (PSrcReg1 >> shiftAmt) & logicalMask, dataSize);
            '''
        big_code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint64_t logicalMask = mask(dataSize * 8 - shiftAmt);
            DestReg = (PSrcReg1 >> shiftAmt) & logicalMask;
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) &&
                        shiftAmt <= dataSize * 8 &&
                        bits(SrcReg1, shiftAmt - 1)) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && bits(SrcReg1, dataSize * 8 - 1))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Sra(BasicRegOp):
        # Because what happens to the bits shift -in- on a right shift
        # is not defined in the C/C++ standard, we have to sign extend
        # them manually to be sure.
        code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint64_t arithMask = (shiftAmt == 0) ? 0 :
                -bits(PSrcReg1, dataSize * 8 - 1) << (dataSize * 8 - shiftAmt);
            DestReg = merge(DestReg, dest,
                    (PSrcReg1 >> shiftAmt) | arithMask, dataSize);
            '''
        big_code = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint64_t arithMask = (shiftAmt == 0) ? 0 :
                -bits(PSrcReg1, dataSize * 8 - 1) << (dataSize * 8 - shiftAmt);
            DestReg =
                ((PSrcReg1 >> shiftAmt) | arithMask) & mask(dataSize * 8);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                //If some combination of the CF bits need to be set, set them.
                uint8_t effectiveShift =
                    (shiftAmt <= dataSize * 8) ? shiftAmt : (dataSize * 8);
                if ((ext & (CFBit | ECFBit)) &&
                        bits(SrcReg1, effectiveShift - 1)) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Ror(BasicRegOp):
        code = '''
            uint8_t shiftAmt =
                (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t realShiftAmt = shiftAmt % (dataSize * 8);
            if (realShiftAmt) {
                uint64_t top = PSrcReg1 << (dataSize * 8 - realShiftAmt);
                uint64_t bottom = bits(PSrcReg1, dataSize * 8, realShiftAmt);
                DestReg = merge(DestReg, dest, top | bottom, dataSize);
            } else
                DestReg = merge(DestReg, dest, DestReg, dataSize);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                //Find the most and second most significant bits of the result.
                int msb = bits(DestReg, dataSize * 8 - 1);
                int smsb = bits(DestReg, dataSize * 8 - 2);
                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) && msb) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (msb ^ smsb))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Rcr(BasicRegOp):
        code = '''
            uint8_t shiftAmt =
                (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t realShiftAmt = shiftAmt % (dataSize * 8 + 1);
            if (realShiftAmt) {
                CCFlagBits flags = cfofBits;
                uint64_t top = flags.cf << (dataSize * 8 - realShiftAmt);
                if (realShiftAmt > 1)
                    top |= PSrcReg1 << (dataSize * 8 - realShiftAmt + 1);
                uint64_t bottom = 0;
                if (realShiftAmt != dataSize * 8)
                    bottom = bits(PSrcReg1, dataSize * 8 - 1, realShiftAmt);
                DestReg = merge(DestReg, dest, top | bottom, dataSize);
            } else
                DestReg = merge(DestReg, dest, DestReg, dataSize);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                int origCFBit = (cfofBits & CFBit) ? 1 : 0;
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (origCFBit ^
                                      bits(SrcReg1, dataSize * 8 - 1))) {
                    PredcfofBits = PredcfofBits | OFBit;
                }
                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) &&
                        (realShiftAmt == 0) ? origCFBit :
                        bits(SrcReg1, realShiftAmt - 1)) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Rol(BasicRegOp):
        code = '''
            uint8_t shiftAmt =
                (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t realShiftAmt = shiftAmt % (dataSize * 8);
            if (realShiftAmt) {
                uint64_t top = PSrcReg1 << realShiftAmt;
                uint64_t bottom = bits(PSrcReg1, dataSize * 8 - 1,
                        dataSize * 8 - realShiftAmt);
                DestReg = merge(DestReg, dest, top | bottom, dataSize);
            } else
                DestReg = merge(DestReg, dest, DestReg, dataSize);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                //The CF bits, if set, would be set to the lsb of the result.
                int lsb = DestReg & 0x1;
                int msb = bits(DestReg, dataSize * 8 - 1);
                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) && lsb) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (msb ^ lsb))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Rcl(BasicRegOp):
        code = '''
            uint8_t shiftAmt =
                (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t realShiftAmt = shiftAmt % (dataSize * 8 + 1);
            if (realShiftAmt) {
                CCFlagBits flags = cfofBits;
                uint64_t top = PSrcReg1 << realShiftAmt;
                uint64_t bottom = flags.cf << (realShiftAmt - 1);
                if(realShiftAmt > 1) {
                    bottom |= bits(PSrcReg1, dataSize * 8 - 1,
                            dataSize * 8 - realShiftAmt + 1);
                }
                DestReg = merge(DestReg, dest, top | bottom, dataSize);
            } else
                DestReg = merge(DestReg, dest, DestReg, dataSize);
            '''
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                int origCFBit = (cfofBits & CFBit) ? 1 : 0;
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);

                int msb = bits(DestReg, dataSize * 8 - 1);
                int CFBits = bits(SrcReg1, dataSize * 8 - realShiftAmt);
                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) &&
                        (realShiftAmt == 0) ? origCFBit : CFBits) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (msb ^ CFBits))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Sld(BasicRegOp):
        sldCode = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t dataBits = dataSize * 8;
            uint8_t realShiftAmt = shiftAmt %% (2 * dataBits);
            uint64_t result;
            if (realShiftAmt == 0) {
                result = PSrcReg1;
            } else if (realShiftAmt < dataBits) {
                result = (PSrcReg1 << realShiftAmt) |
                         (DoubleBits >> (dataBits - realShiftAmt));
            } else {
                result = (DoubleBits << (realShiftAmt - dataBits)) |
                         (PSrcReg1 >> (2 * dataBits - realShiftAmt));
            }
            %s
            '''
        code = sldCode % "DestReg = merge(DestReg, dest, result, dataSize);"
        big_code = sldCode % "DestReg = result & mask(dataSize * 8);"
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);
                int CFBits = 0;

                //Figure out if we -would- set the CF bits if requested.
                if ((realShiftAmt == 0 &&
                        bits(DoubleBits, 0)) ||
                    (realShiftAmt <= dataBits &&
                     bits(SrcReg1, dataBits - realShiftAmt)) ||
                    (realShiftAmt > dataBits &&
                     bits(DoubleBits, 2 * dataBits - realShiftAmt))) {
                    CFBits = 1;
                }

                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) && CFBits) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (bits(SrcReg1, dataBits - 1) ^
                                      bits(result, dataBits - 1)))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Srd(BasicRegOp):
        srdCode = '''
            uint8_t shiftAmt = (op2 & ((dataSize == 8) ? mask(6) : mask(5)));
            uint8_t dataBits = dataSize * 8;
            uint8_t realShiftAmt = shiftAmt %% (2 * dataBits);
            uint64_t result;
            if (realShiftAmt == 0) {
                result = PSrcReg1;
            } else if (realShiftAmt < dataBits) {
                // Because what happens to the bits shift -in- on a right
                // shift is not defined in the C/C++ standard, we have to
                // mask them out to be sure they're zero.
                uint64_t logicalMask = mask(dataBits - realShiftAmt);
                result = ((PSrcReg1 >> realShiftAmt) & logicalMask) |
                         (DoubleBits << (dataBits - realShiftAmt));
            } else {
                uint64_t logicalMask = mask(2 * dataBits - realShiftAmt);
                result = ((DoubleBits >> (realShiftAmt - dataBits)) &
                          logicalMask) |
                         (PSrcReg1 << (2 * dataBits - realShiftAmt));
            }
            %s
            '''
        code = srdCode % "DestReg = merge(DestReg, dest, result, dataSize);"
        big_code = srdCode % "DestReg = result & mask(dataSize * 8);"
        flag_code = '''
            // If the shift amount is zero, no flags should be modified.
            if (shiftAmt) {
                //Zero out any flags we might modify. This way we only have to
                //worry about setting them.
                PredcfofBits = PredcfofBits & ~(ext & (CFBit | OFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);
                int CFBits = 0;

                //If some combination of the CF bits need to be set, set them.
                if ((realShiftAmt == 0 &&
                            bits(DoubleBits, dataBits - 1)) ||
                        (realShiftAmt <= dataBits &&
                         bits(SrcReg1, realShiftAmt - 1)) ||
                        (realShiftAmt > dataBits &&
                         bits(DoubleBits, realShiftAmt - dataBits - 1))) {
                    CFBits = 1;
                }

                //If some combination of the CF bits need to be set, set them.
                if ((ext & (CFBit | ECFBit)) && CFBits) {
                    PredcfofBits = PredcfofBits | (ext & CFBit);
                    PredecfBit = PredecfBit | (ext & ECFBit);
                }

                //Figure out what the OF bit should be.
                if ((ext & OFBit) && (bits(SrcReg1, dataBits - 1) ^
                                      bits(result, dataBits - 1)))
                    PredcfofBits = PredcfofBits | OFBit;

                //Use the regular mechanisms to calculate the other flags.
                uint64_t newFlags = genFlags(PredccFlagBits | PreddfBit |
                                PredezfBit, ext & ~(CFBit | ECFBit | OFBit),
                                DestReg, PSrcReg1, op2);

                PredezfBit = newFlags & EZFBit;
                PreddfBit = newFlags & DFBit;
                PredccFlagBits = newFlags & CcFlagMask;
            }
        '''

    class Mdb(WrRegOp):
        code = 'DoubleBits = PSrcReg1 ^ op2;'

    class Wrip(WrRegOp, CondRegOp):
        code = 'NRIP = ((SrcReg1 + sop2) & mask(dataSize * 8)) + CSBase;'
        else_code = "NRIP = NRIP;"

    class Wruflags(WrRegOp):
        code = '''
            uint64_t newFlags = PSrcReg1 ^ op2;
            cfofBits = newFlags & CfofMask;
            ecfBit = newFlags & ECFBit;
            ezfBit = newFlags & EZFBit;
            dfBit = newFlags & DFBit;
            ccFlagBits = newFlags & CcFlagMask;
        '''

    class Wrflags(WrRegOp):
        code = '''
            const RegVal new_flags = PSrcReg1 ^ op2;

            // Get only the user flags
            ccFlagBits = new_flags & CcFlagMask;
            dfBit = new_flags & DFBit;
            cfofBits = new_flags & CfofMask;
            ecfBit = 0;
            ezfBit = 0;

            // Get everything else
            const RegVal IOPLMask = mask(2) << 12;
            const RegVal SysFlagMask =
                TFBit | IFBit | IOPLMask | NTBit | RFBit | VMBit |
                ACBit | VIFBit | VIPBit | IDBit;
            nccFlagBits = new_flags & SysFlagMask;
        '''

    class Rdip(RdRegOp):
        code = 'DestReg = NRIP - CSBase;'

    class Ruflags(RdRegOp):
        code = 'DestReg = ccFlagBits | cfofBits | dfBit | ecfBit | ezfBit;'

    class Rflags(RdRegOp):
        code = '''
            DestReg = ccFlagBits | cfofBits | dfBit |
                      ecfBit | ezfBit | nccFlagBits | (1 << 1);
            '''

    class Ruflag(RegOp):
        code = '''
            int flag = bits(ccFlagBits | cfofBits | dfBit |
                            ecfBit | ezfBit, imm8);
            DestReg = merge(DestReg, dest, flag, dataSize);
            ezfBit = (flag == 0) ? EZFBit : 0;
            '''

        big_code = '''
            int flag = bits(ccFlagBits | cfofBits | dfBit |
                            ecfBit | ezfBit, imm8);
            DestReg = flag & mask(dataSize * 8);
            ezfBit = (flag == 0) ? EZFBit : 0;
            '''

        operand_types = (FoldedDestOp, Imm8Op)

        def __init__(self, dest, imm, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, imm, flags=flags, dataSize=dataSize)

    class Rflag(RegOp):
        code = '''
            RegVal flagMask = 0x3F7FDD5;
            RegVal flags = (nccFlagBits | ccFlagBits | cfofBits | dfBit |
                             ecfBit | ezfBit) & flagMask;

            int flag = bits(flags, imm8);
            DestReg = merge(DestReg, dest, flag, dataSize);
            ezfBit = (flag == 0) ? EZFBit : 0;
            '''

        big_code = '''
            RegVal flagMask = 0x3F7FDD5;
            RegVal flags = (nccFlagBits | ccFlagBits | cfofBits | dfBit |
                             ecfBit | ezfBit) & flagMask;

            int flag = bits(flags, imm8);
            DestReg = flag & mask(dataSize * 8);
            ezfBit = (flag == 0) ? EZFBit : 0;
            '''

        operand_types = (FoldedDestOp, Imm8Op)
        def __init__(self, dest, imm, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, imm, flags=flags, dataSize=dataSize)

    class Sext(BasicRegOp):
        code = '''
            RegVal val = PSrcReg1;
            // Mask the bit position so that it wraps.
            int bitPos = op2 & (dataSize * 8 - 1);
            int sign_bit = bits(val, bitPos, bitPos);
            uint64_t maskVal = mask(bitPos+1);
            val = sign_bit ? (val | ~maskVal) : (val & maskVal);
            DestReg = merge(DestReg, dest, val, dataSize);
            '''

        big_code = '''
            RegVal val = PSrcReg1;
            // Mask the bit position so that it wraps.
            int bitPos = op2 & (dataSize * 8 - 1);
            int sign_bit = bits(val, bitPos, bitPos);
            uint64_t maskVal = mask(bitPos+1);
            val = sign_bit ? (val | ~maskVal) : (val & maskVal);
            DestReg = val & mask(dataSize * 8);
            '''

        flag_code = '''
            if (!sign_bit) {
                PredccFlagBits = PredccFlagBits & ~(ext & (ZFBit));
                PredcfofBits = PredcfofBits & ~(ext & (CFBit));
                PredecfBit = PredecfBit & ~(ext & ECFBit);
                PredezfBit = PredezfBit & ~(ext & EZFBit);
            } else {
                PredccFlagBits = PredccFlagBits | (ext & (ZFBit));
                PredcfofBits = PredcfofBits | (ext & (CFBit));
                PredecfBit = PredecfBit | (ext & ECFBit);
                PredezfBit = PredezfBit | (ext & EZFBit);
            }
            '''

    class Zext(BasicRegOp):
        code = '''
            DestReg = merge(DestReg, dest, bits(PSrcReg1, op2, 0), dataSize);
        '''
        big_code = 'DestReg = bits(PSrcReg1, op2, 0) & mask(dataSize * 8);'

    class Rddr(RegOp):
        operand_types = (FoldedDestOp, DbgSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        rdrCode = '''
            CR4 cr4 = CR4Op;
            DR7 dr7 = DR7Op;
            if ((cr4.de == 1 && (src1 == 4 || src1 == 5)) || src1 >= 8) {
                fault = std::make_shared<InvalidOpcode>();
            } else if (dr7.gd) {
                fault = std::make_shared<DebugException>();
            } else {
                %s
            }
        '''
        code = rdrCode % "DestReg = merge(DestReg, dest, DebugSrc1, dataSize);"
        big_code = rdrCode % "DestReg = DebugSrc1 & mask(dataSize * 8);"

    class Wrdr(RegOp):
        operand_types = (DbgDestOp, FoldedSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        code = '''
            CR4 cr4 = CR4Op;
            DR7 dr7 = DR7Op;
            if ((cr4.de == 1 && (dest == 4 || dest == 5)) || dest >= 8) {
                fault = std::make_shared<InvalidOpcode>();
            } else if ((dest == 6 || dest == 7) && bits(PSrcReg1, 63, 32) &&
                    machInst.mode.mode == LongMode) {
                fault = std::make_shared<GeneralProtection>(0);
            } else if (dr7.gd) {
                fault = std::make_shared<DebugException>();
            } else {
                DebugDest = PSrcReg1;
            }
        '''

    class Rdcr(RegOp):
        operand_types = (FoldedDestOp, CrSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        rdcrCode = '''
            if (src1 == 1 || (src1 > 4 && src1 < 8) || (src1 > 8)) {
                fault = std::make_shared<InvalidOpcode>();
            } else {
                %s
            }
        '''
        code = rdcrCode % \
                "DestReg = merge(DestReg, dest, ControlSrc1, dataSize);"
        big_code = rdcrCode % "DestReg = ControlSrc1 & mask(dataSize * 8);"

    class Wrcr(RegOp):
        operand_types = (CrDestOp, FoldedSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        code = '''
            if (dest == 1 || (dest > 4 && dest < 8) || (dest > 8)) {
                fault = std::make_shared<InvalidOpcode>();
            } else {
                RegVal newVal = PSrcReg1;

                // Check for any modifications that would cause a fault.
                switch(dest) {
                  case 0:
                    {
                        Efer efer = EferOp;
                        CR0 cr0 = newVal;
                        CR4 oldCr4 = CR4Op;
                        if (bits(newVal, 63, 32) ||
                                (!cr0.pe && cr0.pg) ||
                                (!cr0.cd && cr0.nw) ||
                                (cr0.pg && efer.lme && !oldCr4.pae))
                            fault = std::make_shared<GeneralProtection>(0);
                    }
                    break;
                  case 2:
                    break;
                  case 3:
                    break;
                  case 4:
                    {
                        CR4 cr4 = newVal;
                        // PAE can't be disabled in long mode.
                        if (bits(newVal, 63, 11) ||
                                (machInst.mode.mode == LongMode && !cr4.pae))
                            fault = std::make_shared<GeneralProtection>(0);
                    }
                    break;
                  case 8:
                    {
                        if (bits(newVal, 63, 4))
                            fault = std::make_shared<GeneralProtection>(0);
                    }
                    break;
                  default:
                    fault = std::make_shared<GenericISA::M5PanicFault>(
                            "Unrecognized control register %d.\\n", dest);
                }
                ControlDest = newVal;
            }
            '''

    # Microops for manipulating segmentation registers
    class SegOp(RegOp):
        abstract = True
        operand_types = (SegDestOp, FoldedSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)

    class WrSegOp(SegOp):
        abstract = True
        operand_types = (SegDestOp, FoldedSrc1Op)

    class Wrbase(WrSegOp):
        code = '''
            SegBaseDest = PSrcReg1;
        '''

    class Wrlimit(WrSegOp):
        code = '''
            SegLimitDest = PSrcReg1;
        '''

    class Wrsel(WrSegOp):
        code = '''
            SegSelDest = PSrcReg1;
        '''

    class WrAttr(WrSegOp):
        code = '''
            SegAttrDest = PSrcReg1;
        '''

    class RdSegOp(SegOp):
        abstract = True
        operand_types = (FoldedDestOp, SegSrc1Op)

    class Rdbase(RdSegOp):
        code = 'DestReg = merge(DestReg, dest, SegBaseSrc1, dataSize);'
        big_code = 'DestReg = SegBaseSrc1 & mask(dataSize * 8);'

    class Rdlimit(RdSegOp):
        code = 'DestReg = merge(DestReg, dest, SegLimitSrc1, dataSize);'
        big_code = 'DestReg = SegLimitSrc1 & mask(dataSize * 8);'

    class RdAttr(RdSegOp):
        code = 'DestReg = merge(DestReg, dest, SegAttrSrc1, dataSize);'
        big_code = 'DestReg = SegAttrSrc1 & mask(dataSize * 8);'

    class Rdsel(RdSegOp):
        code = 'DestReg = merge(DestReg, dest, SegSelSrc1, dataSize);'
        big_code = 'DestReg = SegSelSrc1 & mask(dataSize * 8);'

    class Rdval(RegOp):
        operand_types = (FoldedDestOp, MiscSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        code = '''
            DestReg = MiscRegSrc1;
        '''

    class Wrval(RegOp):
        operand_types = (MiscDestOp, FoldedSrc1Op)
        def __init__(self, dest, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(dest, src1, flags=flags, dataSize=dataSize)
        code = '''
            MiscRegDest = SrcReg1;
        '''

    class Chks(RegOp):
        operand_types = (FoldedSrc1Op, FoldedSrc2Op, Imm8Op)
        def __init__(self, src1, src2, imm=0, flags=None,
                dataSize="env.dataSize"):
            super().__init__(src1, src2, imm, flags=flags, dataSize=dataSize)
        code = '''
            // The selector is in source 1 and can be at most 16 bits.
            SegSelector selector = SrcReg1;
            SegDescriptor desc = SrcReg2;
            HandyM5Reg m5reg = M5Reg;

            switch (imm8)
            {
              case SegNoCheck:
                break;
              case SegCSCheck:
                // Make sure it's the right type
                if (desc.s == 0 || desc.type.codeOrData != 1) {
                    fault = std::make_shared<GeneralProtection>(0);
                } else if (m5reg.cpl != desc.dpl) {
                    fault = std::make_shared<GeneralProtection>(0);
                }
                break;
              case SegCallGateCheck:
                fault = std::make_shared<GenericISA::M5PanicFault>(
                        "CS checks for far "
                        "calls/jumps through call gates not implemented.\\n");
                break;
              case SegSoftIntGateCheck:
                // Check permissions.
                if (desc.dpl < m5reg.cpl) {
                    fault = std::make_shared<GeneralProtection>(selector);
                    break;
                }
                [[fallthrough]];
              case SegIntGateCheck:
                // Make sure the gate's the right type.
                if ((m5reg.mode == LongMode && (desc.type & 0xe) != 0xe) ||
                        ((desc.type & 0x6) != 0x6)) {
                    fault = std::make_shared<GeneralProtection>(0);
                }
                break;
              case SegSSCheck:
                if (selector.si || selector.ti) {
                    if (!desc.p) {
                        fault = std::make_shared<StackFault>(selector);
                    } else if (!(desc.s == 1 && desc.type.codeOrData == 0 &&
                                desc.type.w) ||
                            (desc.dpl != m5reg.cpl) ||
                            (selector.rpl != m5reg.cpl)) {
                        fault = std::make_shared<GeneralProtection>(selector);
                    }
                } else if (m5reg.submode != SixtyFourBitMode ||
                        m5reg.cpl == 3) {
                    fault = std::make_shared<GeneralProtection>(selector);
                }
                break;
              case SegIretCheck:
                {
                    if ((!selector.si && !selector.ti) ||
                            (selector.rpl < m5reg.cpl) ||
                            !(desc.s == 1 && desc.type.codeOrData == 1) ||
                            (!desc.type.c && desc.dpl != selector.rpl) ||
                            (desc.type.c && desc.dpl > selector.rpl)) {
                        fault = std::make_shared<GeneralProtection>(selector);
                    } else if (!desc.p) {
                        fault = std::make_shared<SegmentNotPresent>(selector);
                    }
                    break;
                }
              case SegIntCSCheck:
                if (desc.type.codeOrData != 1) {
                    fault = std::make_shared<GeneralProtection>(selector);
                } else if (m5reg.mode == LongMode) {
                    if (desc.l != 1 || desc.d != 0) {
                        fault = std::make_shared<GeneralProtection>(selector);
                    }
                }
                break;
              case SegTRCheck:
                if (!selector.si || selector.ti) {
                    fault = std::make_shared<GeneralProtection>(selector);
                }
                break;
              case SegTSSCheck:
                if (!desc.p) {
                    fault = std::make_shared<SegmentNotPresent>(selector);
                } else if (!(desc.type == 0x9 ||
                        (desc.type == 1 &&
                         m5reg.mode != LongMode))) {
                    fault = std::make_shared<GeneralProtection>(selector);
                }
                break;
              case SegInGDTCheck:
                if (selector.ti) {
                    fault = std::make_shared<GeneralProtection>(selector);
                }
                break;
              case SegLDTCheck:
                if (!desc.p) {
                    fault = std::make_shared<SegmentNotPresent>(selector);
                } else if (desc.type != 0x2) {
                    fault = std::make_shared<GeneralProtection>(selector);
                }
                break;
              default:
                fault = std::make_shared<GenericISA::M5PanicFault>(
                        "Undefined segment check type.\\n");
            }
        '''
        flag_code = '''
            // Check for a NULL selector and set ZF,EZF appropriately.
            PredccFlagBits = PredccFlagBits & ~(ext & ZFBit);
            PredezfBit = PredezfBit & ~(ext & EZFBit);

            if (!selector.si && !selector.ti) {
                PredccFlagBits = PredccFlagBits | (ext & ZFBit);
                PredezfBit = PredezfBit | (ext & EZFBit);
            }
        '''

    class Wrdh(BasicRegOp):
        code = '''
            SegDescriptor desc = SrcReg1;

            uint64_t target = bits(SrcReg2, 31, 0) << 32;
            switch(desc.type) {
              case LDT64:
              case AvailableTSS64:
              case BusyTSS64:
                replaceBits(target, 31, 0, desc.base);
                break;
              case CallGate64:
              case IntGate64:
              case TrapGate64:
                replaceBits(target, 15, 0, bits(desc, 15, 0));
                replaceBits(target, 31, 16, bits(desc, 63, 48));
                break;
              default:
                fault = std::make_shared<GenericISA::M5PanicFault>(
                        "Wrdh used with wrong descriptor type!\\n");
            }
            DestReg = target;
        '''

    class Wrtsc(WrRegOp):
        code = 'TscOp = PSrcReg1;'

    class Rdtsc(RdRegOp):
        code = '''
            DestReg = TscOp;
        '''

    class Rdm5reg(RdRegOp):
        code = '''
            DestReg = M5Reg;
        '''

    class Wrdl(BasicRegOp):
        operand_types = (SegDestOp, FoldedSrc1Op, Op2)
        code = '''
            SegDescriptor desc = SrcReg1;
            SegSelector selector = SrcReg2;
            // This while loop is so we can use break statements in the code
            // below to skip the rest of this section without a bunch of
            // nesting.
            while (true) {
                if (selector.si || selector.ti) {
                    if (!desc.p) {
                        fault = std::make_shared<GenericISA::M5PanicFault>(
                                "Segment not present.\\n");
                        break;
                    }
                    SegAttr attr = 0;
                    attr.dpl = desc.dpl;
                    attr.unusable = 0;
                    attr.defaultSize = desc.d;
                    attr.longMode = desc.l;
                    attr.avl = desc.avl;
                    attr.granularity = desc.g;
                    attr.present = desc.p;
                    attr.system = desc.s;
                    attr.type = desc.type;
                    if (!desc.s) {
                        // The expand down bit happens to be set for gates.
                        if (desc.type.e) {
                            fault = std::make_shared<GenericISA::M5PanicFault>(
                                    "Gate descriptor encountered.\\n");
                            break;
                        }
                        attr.readable = 1;
                        attr.writable = 1;
                        attr.expandDown = 0;
                    } else {
                        if (desc.type.codeOrData) {
                            attr.expandDown = 0;
                            attr.readable = desc.type.r;
                            attr.writable = 0;
                        } else {
                            attr.expandDown = desc.type.e;
                            attr.readable = 1;
                            attr.writable = desc.type.w;
                        }
                    }
                    SegBaseDest = desc.base;
                    SegLimitDest = desc.limit;
                    SegAttrDest = attr;
                } else {
                    HandyM5Reg m5reg = M5Reg;

                    SegBaseDest = SegBaseDest;
                    SegLimitDest = SegLimitDest;

                    SegAttr attr = SegAttrDest;
                    if (m5reg != LongMode)
                        attr.unusable = 1;
                    SegAttrDest = attr;
                }
                break;
            }
        '''

    class Wrxftw(RegOp):
        operand_types = (FoldedSrc1Op,)
        def __init__(self, src1, flags=None, dataSize="env.dataSize"):
            super().__init__(src1, flags=None, dataSize=dataSize)

        code = '''
            FTW = X86ISA::convX87XTagsToTags(SrcReg1);
        '''

    class Rdxftw(RdRegOp):
        code = '''
            DestReg = X86ISA::convX87TagsToXTags(FTW);
        '''

    class Popcnt(BasicRegOp):
        code = 'DestReg = merge(DestReg, dest, popCount(PSrcReg1), dataSize);'
        flag_code = '''
            ccFlagBits = ccFlagBits & ~(X86ISA::SFBit | X86ISA::AFBit |
                    X86ISA::ZFBit | X86ISA::PFBit);
            if (findZero(dataSize * 8, SrcReg1)) {
                ccFlagBits = ccFlagBits | X86ISA::ZFBit;
            }
            cfofBits = cfofBits & ~(X86ISA::OFBit | X86ISA::CFBit);
        '''
}};

// Copyright (c) 2007 The Hewlett-Packard Development Company
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms,
// with or without modification, are permitted provided that the
// following conditions are met:
//
// The software must be used only for Non-Commercial Use which means any
// use which is NOT directed to receiving any direct monetary
// compensation for, or commercial advantage from such use.  Illustrative
// examples of non-commercial use are academic research, personal study,
// teaching, education and corporate research & development.
// Illustrative examples of commercial use are distributing products for
// commercial advantage and providing services using the software for
// commercial advantage.
//
// If you wish to use this software or functionality therein that may be
// covered by patents for commercial use, please contact:
//     Director of Intellectual Property Licensing
//     Office of Strategy and Technology
//     Hewlett-Packard Company
//     1501 Page Mill Road
//     Palo Alto, California  94304
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.  Redistributions
// in binary form must reproduce the above copyright notice, this list of
// conditions and the following disclaimer in the documentation and/or
// other materials provided with the distribution.  Neither the name of
// the COPYRIGHT HOLDER(s), HEWLETT-PACKARD COMPANY, nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.  No right of
// sublicense is granted herewith.  Derivatives of the software and
// output created using the software may be prepared, but only for
// Non-Commercial Uses.  Derivatives of the software may be shared with
// others provided: (i) the others agree to abide by the list of
// conditions herein which includes the Non-Commercial Use restrictions;
// and (ii) such Derivatives of the software include the above copyright
// notice to acknowledge the contribution from this software where
// applicable, this list of conditions and the disclaimer below.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

////////////////////////////////////////////////////////////////////
//
// Decode the one byte opcodes
//

0x1: decode OPCODE_OP_TOP5 {
    format WarnUnimpl {
        0x00: decode OPCODE_OP_BOTTOM3 {
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: push_ES();
            }
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: pop_ES();
            }
            default: MultiInst::ADD(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x01: decode OPCODE_OP_BOTTOM3 {
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: push_CS();
            }
            //Any time this is seen, it should generate a two byte opcode
            0x7: M5InternalError::error(
                {{"Saw a one byte opcode whose value was 0x0F!"}});
            default: MultiInst::OR(OPCODE_OP_BOTTOM3,
                                   [Eb,Gb], [Ev,Gv],
                                   [Gb,Eb], [Gv,Ev],
                                   [rAb,Ib], [rAv,Iz]);
        }
        0x02: decode OPCODE_OP_BOTTOM3 {
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: push_SS();
            }
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: pop_SS();
            }
            default: MultiInst::ADC(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x03: decode OPCODE_OP_BOTTOM3 {
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: push_DS();
            }
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: pop_DS();
            }
            default: MultiInst::SBB(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x04: decode OPCODE_OP_BOTTOM3 {
            0x6: M5InternalError::error(
                {{"Tried to execute the ES segment override prefix!"}});
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: daa();
            }
            default: MultiInst::AND(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x05: decode OPCODE_OP_BOTTOM3 {
            0x6: M5InternalError::error(
                {{"Tried to execute the CS segment override prefix!"}});
            0x7: das();
            default: MultiInst::SUB(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x06: decode OPCODE_OP_BOTTOM3 {
            0x6: M5InternalError::error(
                {{"Tried to execute the SS segment override prefix!"}});
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: aaa();
            }
            default: MultiInst::XOR(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        0x07: decode OPCODE_OP_BOTTOM3 {
            0x6: M5InternalError::error(
                {{"Tried to execute the DS segment override prefix!"}});
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: aas();
            }
            default: MultiInst::CMP(OPCODE_OP_BOTTOM3,
                                    [Eb,Gb], [Ev,Gv],
                                    [Gb,Eb], [Gv,Ev],
                                    [rAb,Ib], [rAv,Iz]);
        }
        format Inst {
            0x08: decode MODE_SUBMODE {
                0x0: M5InternalError::error (
                    {{"Tried to execute an REX prefix!"}});
                default: INC(Bv);
            }
            0x09: decode MODE_SUBMODE {
                0x0: M5InternalError::error (
                    {{"Tried to execute an REX prefix!"}});
                default: DEC(Bv);
            }
            0x0A: PUSH(Bv);
            0x0B: POP(Bv);
        }
        0x0C: decode OPCODE_OP_BOTTOM3 {
            0x0: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: Inst::PUSHA();
            }
            0x1: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: Inst::POPA();
            }
            0x2: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: bound_Gv_Ma();
            }
            0x3: decode MODE_SUBMODE {
                //The second operand should really be of size "d", but it's
                //set to "v" in order to have a consistent register size.
                //This shouldn't affect behavior.
                0x0: Inst::MOVSXD(Gv,Ev);
                default: arpl_Ew_Gw();
            }
            0x4: M5InternalError::error(
                {{"Tried to execute the FS segment override prefix!"}});
            0x5: M5InternalError::error(
                {{"Tried to execute the GS segment override prefix!"}});
            0x6: M5InternalError::error(
                {{"Tried to execute the operand size override prefix!"}});
            0x7: M5InternalError::error(
                {{"Tried to execute the DS address size override prefix!"}});
        }
        0x0D: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::PUSH(Iz);
            0x1: Inst::IMUL(Gv,Ev,Iz);
            0x2: Inst::PUSH(Ib);
            0x3: Inst::IMUL(Gv,Ev,Ib);
            0x4: ins_Yb_Dx();
            0x5: ins_Yz_Dx();
            0x6: outs_Dx_Xb();
            0x7: outs_Dx_Xz();
        }
        format Inst {
            0x0E: decode OPCODE_OP_BOTTOM3 {
                0x0: JO(Jb);
                0x1: JNO(Jb);
                0x2: JB(Jb);
                0x3: JNB(Jb);
                0x4: JZ(Jb);
                0x5: JNZ(Jb);
                0x6: JBE(Jb);
                0x7: JNBE(Jb);
            }
            0x0F: decode OPCODE_OP_BOTTOM3 {
                0x0: JS(Jb);
                0x1: JNS(Jb);
                0x2: JP(Jb);
                0x3: JNP(Jb);
                0x4: JL(Jb);
                0x5: JNL(Jb);
                0x6: JLE(Jb);
                0x7: JNLE(Jb);
            }
        }
        format Inst {
            0x10: decode OPCODE_OP_BOTTOM3 {
                //0x0: group1_Eb_Ib();
                0x0: decode MODRM_REG {
                    0x0: ADD(Eb,Ib);
                    0x1: OR(Eb,Ib);
                    0x2: ADC(Eb,Ib);
                    0x3: SBB(Eb,Ib);
                    0x4: AND(Eb,Ib);
                    0x5: SUB(Eb,Ib);
                    0x6: XOR(Eb,Ib);
                    0x7: CMP(Eb,Ib);
                }
                //0x1: group1_Ev_Iz();
                0x1: decode MODRM_REG {
                    0x0: ADD(Ev,Iz);
                    0x1: OR(Ev,Iz);
                    0x2: ADC(Ev,Iz);
                    0x3: SBB(Ev,Iz);
                    0x4: AND(Ev,Iz);
                    0x5: SUB(Ev,Iz);
                    0x6: XOR(Ev,Iz);
                    0x7: CMP(Ev,Iz);
                }
                0x2: decode MODE_SUBMODE {
                    0x0: UD2();
                    //default: group1_Eb_Ib();
                    default: decode MODRM_REG {
                        0x0: ADD(Eb,Ib);
                        0x1: OR(Eb,Ib);
                        0x2: ADC(Eb,Ib);
                        0x3: SBB(Eb,Ib);
                        0x4: AND(Eb,Ib);
                        0x5: SUB(Eb,Ib);
                        0x6: XOR(Eb,Ib);
                        0x7: CMP(Eb,Ib);
                    }
                }
                //0x3: group1_Ev_Ib();
                0x3: decode MODRM_REG {
                    0x0: ADD(Ev,Ib);
                    0x1: OR(Ev,Ib);
                    0x2: ADC(Ev,Ib);
                    0x3: SBB(Ev,Ib);
                    0x4: AND(Ev,Ib);
                    0x5: SUB(Ev,Ib);
                    0x6: XOR(Ev,Ib);
                    0x7: CMP(Ev,Ib);
                }
                0x4: TEST(Eb,Gb);
                0x5: TEST(Ev,Gv);
                0x6: XCHG(Eb,Gb);
                0x7: XCHG(Ev,Gv);
            }
        }
        0x11: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::MOV(Eb,Gb);
            0x1: Inst::MOV(Ev,Gv);
            0x2: Inst::MOV(Gb,Eb);
            0x3: Inst::MOV(Gv,Ev);
            0x4: mov_MwRv_Sw(); //What to do with this one?
            0x5: Inst::LEA(Gv,M);
            0x6: mov_Sw_MwRv();
            0x7: group10_Ev(); //Make sure this is Ev
        }
        0x12: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::NOP(); //XXX repe makes this a "pause"
            default: xchg_B_rAX();
        }
        0x13: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::CDQE(rAv);
            0x1: Inst::CQO(rAv,rDv);
            0x2: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: call_far_Ap();
            }
            0x3: fwait(); //aka wait
            0x4: pushf_Fv();
            0x5: popf_Fv();
            //Both of these should be illegal only if CPUID.AHF64=0,
            //according to sandpile.org
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: sahf();
            }
            0x7: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: lahf();
            }
        }
        0x14: decode OPCODE_OP_BOTTOM3 {
            0x0: mov_Al_Ob();
            0x1: mov_rAX_Ov();
            0x2: mov_Ob_Al();
            0x3: mov_Ov_rAX();
            0x4: movs_Yb_Xb();
            0x5: movs_Yv_Xv();
            0x6: cmps_Yb_Xb();
            0x7: cmps_Yv_Xv();
        }
        0x15: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::TEST(rAb,Ib);
            0x1: Inst::TEST(rAv,Iz);
            0x2: stos_Yb_Al();
            0x3: stos_Yv_rAX();
            0x4: lods_Al_Xb();
            0x5: lods_rAX_Xv();
            0x6: scas_Yb_Al();
            0x7: scas_Yv_rAX();
        }
        format Inst {
            0x16: MOV(Bb,Ib);
            0x17: MOV(Bv,Iv);
            0x18: decode OPCODE_OP_BOTTOM3 {
                //0x0: group2_Eb_Ib();
                0x0: decode MODRM_REG {
                    0x0: ROL(Eb,Ib);
                    0x1: ROR(Eb,Ib);
                    0x2: RCL(Eb,Ib);
                    0x3: RCR(Eb,Ib);
                    0x4: SAL(Eb,Ib);
                    0x5: SHR(Eb,Ib);
                    0x6: SAL(Eb,Ib);
                    0x7: SAR(Eb,Ib);
                }
                //0x1: group2_Ev_Ib();
                0x1: decode MODRM_REG {
                    0x0: ROL(Ev,Ib);
                    0x1: ROR(Ev,Ib);
                    0x2: RCL(Ev,Ib);
                    0x3: RCR(Ev,Ib);
                    0x4: SAL(Ev,Ib);
                    0x5: SHR(Ev,Ib);
                    0x6: SAL(Ev,Ib);
                    0x7: SAR(Ev,Ib);
                }
                0x2: RET_NEAR(Iw);
                0x3: RET_NEAR();
                0x4: decode MODE_SUBMODE {
                    0x0: UD2();
                    default: WarnUnimpl::les_Gz_Mp();
                }
                0x5: decode MODE_SUBMODE {
                    0x0: UD2();
                    default: WarnUnimpl::lds_Gz_Mp();
                }
                //0x6: group12_Eb_Ib();
                0x6: decode MODRM_REG {
                    0x0: MOV(Eb,Ib);
                    default: UD2();
                }
                //0x7: group12_Ev_Iz();
                0x7: decode MODRM_REG {
                    0x0: MOV(Ev,Iz);
                    default: UD2();
                }
            }
        }
        0x19: decode OPCODE_OP_BOTTOM3 {
            0x0: enter_Iw_Ib();
            0x1: Inst::LEAVE();
            0x2: ret_far_Iw();
            0x3: ret_far();
            0x4: int3();
            0x5: int_Ib();
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: into();
            }
            0x7: iret();
        }
        0x1A: decode OPCODE_OP_BOTTOM3 {
            format Inst {
                //0x0: group2_Eb_1();
                0x0: decode MODRM_REG {
                    0x0: ROL_1(Eb);
                    0x1: ROR_1(Eb);
                    0x2: RCL_1(Eb);
                    0x3: RCR_1(Eb);
                    0x4: SAL_1(Eb);
                    0x5: SHR_1(Eb);
                    0x6: SAL_1(Eb);
                    0x7: SAR_1(Eb);
                }
                //0x1: group2_Ev_1();
                0x1: decode MODRM_REG {
                    0x0: ROL_1(Ev);
                    0x1: ROR_1(Ev);
                    0x2: RCL_1(Ev);
                    0x3: RCR_1(Ev);
                    0x4: SAL_1(Ev);
                    0x5: SHR_1(Ev);
                    0x6: SAL_1(Ev);
                    0x7: SAR_1(Ev);
                }
                //0x2: group2_Eb_Cl();
                0x2: decode MODRM_REG {
                    0x0: ROL(Eb,rCb);
                    0x1: ROR(Eb,rCb);
                    0x2: RCL(Eb,rCb);
                    0x3: RCR(Eb,rCb);
                    0x4: SAL(Eb,rCb);
                    0x5: SHR(Eb,rCb);
                    0x6: SAL(Eb,rCb);
                    0x7: SAR(Eb,rCb);
                }
                //The second operand should have size "b", but to have
                //consistent register sizes it's "v". This shouldn't have
                //any affect on functionality.
                //0x3: group2_Ev_Cl();
                0x3: decode MODRM_REG {
                    0x0: ROL(Ev,rCv);
                    0x1: ROR(Ev,rCv);
                    0x2: RCL(Ev,rCv);
                    0x3: RCR(Ev,rCv);
                    0x4: SAL(Ev,rCv);
                    0x5: SHR(Ev,rCv);
                    0x6: SAL(Ev,rCv);
                    0x7: SAR(Ev,rCv);
                }
            }
            0x4: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: aam_Ib();
            }
            0x5: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: aad_Ib();
            }
            0x6: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: salc();
            }
            0x7: xlat();
        }
        0x1B: decode OPCODE_OP_BOTTOM3 {
            0x0: esc0();
            0x1: esc1();
            0x2: esc2();
            0x3: esc3();
            0x4: esc4();
            0x5: esc5();
            0x6: esc6();
            0x7: esc7();
        }
        0x1C: decode OPCODE_OP_BOTTOM3 {
            0x0: loopne_Jb();
            0x1: loope_Jb();
            0x2: loop_Jb();
            0x3: jcxz_or_jecx_or_jrcx();
            0x4: in_Al_Ib();
            0x5: in_eAX_Ib();
            0x6: out_Ib_Al();
            0x7: out_Ib_eAX();
        }
        0x1D: decode OPCODE_OP_BOTTOM3 {
            0x0: Inst::CALL_NEAR(Jz);
            0x1: Inst::JMP(Jz);
            0x2: decode MODE_SUBMODE {
                0x0: Inst::UD2();
                default: jmp_far_Ap();
            }
            0x3: Inst::JMP(Jb);
            0x4: in_Al_Dx();
            0x5: in_eAX_Dx();
            0x6: out_Dx_Al();
            0x7: out_Dx_eAX();
        }
        0x1E: decode OPCODE_OP_BOTTOM3 {
            0x0: M5InternalError::error(
                {{"Tried to execute the lock prefix!"}});
            0x1: int1();
            0x2: M5InternalError::error(
                {{"Tried to execute the repne prefix!"}});
            0x3: M5InternalError::error(
                {{"Tried to execute the rep/repe prefix!"}});
            0x4: hlt();
            0x5: cmc();
            //0x6: group3_Eb();
            0x6: decode MODRM_REG {
                0x0: Inst::TEST(Eb,Iz);
                0x1: Inst::TEST(Eb,Iz);
                0x2: Inst::NOT(Eb);
                0x3: Inst::NEG(Eb);
                0x4: Inst::MUL_B(Eb);
                0x5: Inst::IMUL_B(Eb);
                //This should be Eb, but it access the entire word value ax.
                0x6: Inst::DIV_B(Ew);
                0x7: idiv_Eb();
            }
            //0x7: group3_Ev();
            0x7: decode MODRM_REG {
                0x0: Inst::TEST(Ev,Iz);
                0x1: Inst::TEST(Ev,Iz);
                0x2: Inst::NOT(Ev);
                0x3: Inst::NEG(Ev);
                0x4: Inst::MUL(Ev);
                0x5: Inst::IMUL(Ev);
                0x6: Inst::DIV(Ev);
                0x7: idiv_Ev();
            }
        }
        0x1F: decode OPCODE_OP_BOTTOM3 {
            0x0: clc();
            0x1: stc();
            0x2: cli();
            0x3: sti();
            0x4: cld();
            0x5: std();
            format Inst {
                //0x6: group4();
                0x6: decode MODRM_REG {
                    0x0: INC(Eb);
                    0x1: DEC(Eb);
                    default: UD2();
                }
                //0x7: group5();
                0x7: decode MODRM_REG {
                    0x0: INC(Ev);
                    0x1: DEC(Ev);
                    0x2: CALL_NEAR(Ev);
                    0x3: WarnUnimpl::call_far_Mp();
                    0x4: JMP(Ev);
                    0x5: WarnUnimpl::jmp_far_Mp();
                    0x6: PUSH(Ev);
                    0x7: UD2();
                }
            }
        }
    }
    default: FailUnimpl::oneByteOps();
}

// Copyright (c) 2008 The Regents of The University of Michigan
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

// Copyright (c) 2007-2008 The Hewlett-Packard Development Company
// All rights reserved.
//
// Redistribution and use of this software in source and binary forms,
// with or without modification, are permitted provided that the
// following conditions are met:
//
// The software must be used only for Non-Commercial Use which means any
// use which is NOT directed to receiving any direct monetary
// compensation for, or commercial advantage from such use.  Illustrative
// examples of non-commercial use are academic research, personal study,
// teaching, education and corporate research & development.
// Illustrative examples of commercial use are distributing products for
// commercial advantage and providing services using the software for
// commercial advantage.
//
// If you wish to use this software or functionality therein that may be
// covered by patents for commercial use, please contact:
//     Director of Intellectual Property Licensing
//     Office of Strategy and Technology
//     Hewlett-Packard Company
//     1501 Page Mill Road
//     Palo Alto, California  94304
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.  Redistributions
// in binary form must reproduce the above copyright notice, this list of
// conditions and the following disclaimer in the documentation and/or
// other materials provided with the distribution.  Neither the name of
// the COPYRIGHT HOLDER(s), HEWLETT-PACKARD COMPANY, nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.  No right of
// sublicense is granted herewith.  Derivatives of the software and
// output created using the software may be prepared, but only for
// Non-Commercial Uses.  Derivatives of the software may be shared with
// others provided: (i) the others agree to abide by the list of
// conditions herein which includes the Non-Commercial Use restrictions;
// and (ii) such Derivatives of the software include the above copyright
// notice to acknowledge the contribution from this software where
// applicable, this list of conditions and the disclaimer below.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Gabe Black

////////////////////////////////////////////////////////////////////
//
// Decode the two byte opcodes
//
0x2: decode OPCODE_PREFIXA {
    0x0F: decode OPCODE_OP_TOP5 {
        format WarnUnimpl {
            0x00: decode OPCODE_OP_BOTTOM3 {
                //0x00: group6();
                0x00: decode MODRM_REG {
                    0x0: sldt_Mw_or_Rv();
                    0x1: str_Mw_or_Rv();
                    0x2: Inst::LLDT(Ew);
                    0x3: Inst::LTR(Ew);
                    0x4: verr_Mw_or_Rv();
                    0x5: verw_Mw_or_Rv();
                    //0x6: jmpe_Ev(); // IA-64
                    default: Inst::UD2();
                }
                //0x01: group7(); // Ugly, ugly, ugly...
                0x01: decode MODRM_MOD {
                    0x3: decode MODRM_REG {
                        0x0: decode MODRM_RM {
                            0x1: vmcall();
                            0x2: vmlaunch();
                            0x3: vmresume();
                            0x4: vmxoff();
                            default: Inst::UD2();
                        }
                        0x1: decode MODRM_RM {
                            0x0: monitor();
                            0x1: mwait();
                            default: Inst::UD2();
                        }
                        0x3: decode MODRM_RM {
                            0x0: vmrun();
                            0x1: vmmcall();
                            0x2: vmload();
                            0x3: vmsave();
                            0x4: stgi();
                            0x5: clgi();
                            0x6: skinit();
                            0x7: invlpga();
                        }
                        0x4: Inst::SMSW(Rv);
                        0x6: Inst::LMSW(Rv);
                        0x7: decode MODRM_RM {
                            0x0: Inst::SWAPGS();
                            0x1: rdtscp();
                            default: Inst::UD2();
                        }
                        default: Inst::UD2();
                    }
                    default: decode MODRM_REG {
                        0x0: sgdt_Ms();
                        0x1: sidt_Ms();
                        0x2: decode MODE_SUBMODE {
                            0x0: Inst::LGDT(M);
                            default: decode OPSIZE {
                                // 16 bit operand sizes are special, but only
                                // in legacy and compatability modes.
                                0x2: Inst::LGDT_16(M);
                                default: Inst::LGDT(M);
                            }
                        }
                        0x3: decode MODE_SUBMODE {
                            0x0: Inst::LIDT(M);
                            default: decode OPSIZE {
                                // 16 bit operand sizes are special, but only
                                // in legacy and compatability modes.
                                0x2: Inst::LIDT_16(M);
                                default: Inst::LIDT(M);
                            }
                        }
                        0x4: Inst::SMSW(Mw);
                        0x6: Inst::LMSW(Mw);
                        0x7: Inst::INVLPG(M);
                        default: Inst::UD2();
                    }
                }
                0x02: lar_Gv_Ew();
                0x03: lsl_Gv_Ew();
                // sandpile.org doesn't seem to know what this is...? We'll
                // use it for pseudo instructions. We've got 16 bits of space
                // to play with so there can be quite a few pseudo
                // instructions.
                //0x04: loadall_or_reset_or_hang();
                0x4: decode IMMEDIATE {
                    format BasicOperate {
#if FULL_SYSTEM
                        0x00: m5arm({{
                            PseudoInst::arm(xc->tcBase());
                        }}, IsNonSpeculative);
                        0x01: m5quiesce({{
                            PseudoInst::quiesce(xc->tcBase());
                        }}, IsNonSpeculative);
                        0x02: m5quiesceNs({{
                            PseudoInst::quiesceNs(xc->tcBase(), Rdi);
                        }}, IsNonSpeculative);
                        0x03: m5quiesceCycle({{
                            PseudoInst::quiesceCycles(xc->tcBase(), Rdi);
                        }}, IsNonSpeculative);
                        0x04: m5quiesceTime({{
                            Rax = PseudoInst::quiesceTime(xc->tcBase());
                        }}, IsNonSpeculative);
#endif
                        0x07: m5rpns({{
                            Rax = PseudoInst::rpns(xc->tcBase());
                        }}, IsNonSpeculative);
                        0x21: m5exit({{
                            PseudoInst::m5exit(xc->tcBase(), Rdi);
                        }}, IsNonSpeculative);
#if FULL_SYSTEM
                        0x30: m5initparam({{
                            Rax = xc->tcBase()->getCpuPtr()->
                                      system->init_param;
                        }}, IsNonSpeculative);
                        0x31: m5loadsymbol({{
                            PseudoInst::loadsymbol(xc->tcBase());
                        }}, IsNonSpeculative);
#endif
                        0x40: m5resetstats({{
                            PseudoInst::resetstats(xc->tcBase(), Rdi, Rsi);
                        }}, IsNonSpeculative);
                        0x41: m5dumpstats({{
                            PseudoInst::dumpstats(xc->tcBase(), Rdi, Rsi);
                        }}, IsNonSpeculative);
                        0x42: m5dumpresetstats({{
                            PseudoInst::dumpresetstats(xc->tcBase(), Rdi, Rsi);
                        }}, IsNonSpeculative);
                        0x43: m5checkpoint({{
                            PseudoInst::m5checkpoint(xc->tcBase(), Rdi, Rsi);
                        }}, IsNonSpeculative);
#if FULL_SYSTEM
                        0x50: m5readfile({{
                            Rax = PseudoInst::readfile(
                                xc->tcBase(), Rdi, Rsi, Rdx);
                        }}, IsNonSpeculative);
#endif
                        0x51: m5debugbreak({{
                            PseudoInst::debugbreak(xc->tcBase());
                        }}, IsNonSpeculative);
                        0x52: m5switchcpu({{
                            PseudoInst::switchcpu(xc->tcBase());
                        }}, IsNonSpeculative);
#if FULL_SYSTEM
                        0x53: m5addsymbol({{
                            PseudoInst::addsymbol(xc->tcBase(), Rdi, Rsi);
                        }}, IsNonSpeculative);
#endif
                        0x54: m5panic({{
                            panic("M5 panic instruction called at pc=%#x.\n",
                                xc->readPC());
                        }}, IsNonSpeculative);
                        0x55: m5reserved1({{
                            warn("M5 reserved opcode 1 ignored.\n");
                        }}, IsNonSpeculative);
                        0x56: m5reserved2({{
                            warn("M5 reserved opcode 2 ignored.\n");
                        }}, IsNonSpeculative);
                        0x57: m5reserved3({{
                            warn("M5 reserved opcode 3 ignored.\n");
                        }}, IsNonSpeculative);
                        0x58: m5reserved4({{
                            warn("M5 reserved opcode 4 ignored.\n");
                        }}, IsNonSpeculative);
                        0x59: m5reserved5({{
                            warn("M5 reserved opcode 5 ignored.\n");
                        }}, IsNonSpeculative);
                        default: Inst::UD2();
                    }
                }
#if FULL_SYSTEM
                0x05: decode MODE_MODE {
                    0x0: decode MODE_SUBMODE {
                        0x0: Inst::SYSCALL_64();
                        0x1: Inst::SYSCALL_COMPAT();
                    }
                    0x1: Inst::SYSCALL_LEGACY();
                }
#else
                0x05: SyscallInst::syscall('xc->syscall(Rax)', IsSyscall);
#endif
                0x06: Inst::CLTS();
                0x07: decode MODE_SUBMODE {
                    0x0: decode OPSIZE {
                        // Return to 64 bit mode.
                        0x8: Inst::SYSRET_TO_64();
                        // Return to compatibility mode.
                        default: Inst::SYSRET_TO_COMPAT();
                    }
                    default: Inst::SYSRET_NON_64();
                }
            }
            0x01: decode OPCODE_OP_BOTTOM3 {
                0x0: invd();
                0x1: wbinvd();
                0x2: Inst::UD2();
                0x3: Inst::UD2();
                0x4: Inst::UD2();
                0x5: Inst::PREFETCH(Mb);
                0x6: FailUnimpl::femms();
                0x7: FailUnimpl::threednow();
            }
            format Inst{
                0x02: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOVUPS(Vo,Wo);
                        0x1: MOVUPS(Wo,Vo);
                        0x2: decode MODRM_MOD {
                            0x3: MOVHLPS(Vq,VRq);
                            default: MOVLPS(Vq,Mq);
                        }
                        0x3: MOVLPS(Mq,Vq);
                        0x4: UNPCKLPS(Vps,Wq);
                        0x5: UNPCKHPS(Vpd,Wq);
                        0x6: decode MODRM_MOD {
                            0x3: MOVLHPS(Vq,VRq);
                            default: MOVHPS(Vq,Mq);
                        }
                        0x7: MOVHPS(Mq,Vq);
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::movss_Vd_Wd();
                        0x1: WarnUnimpl::movss_Wd_Vd();
                        0x2: WarnUnimpl::movsldup_Vo_Wo();
                        0x6: WarnUnimpl::movshdup_Vo_Wo();
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOVUPD(Vo,Wo);
                        0x1: MOVUPD(Wo,Vo);
                        0x2: MOVLPD(Vq,Mq);
                        0x3: MOVLPD(Mq,Vq);
                        0x4: UNPCKLPD(Vo,Wq);
                        0x5: UNPCKHPD(Vo,Wo);
                        0x6: MOVHPD(Vq,Mq);
                        0x7: MOVHPD(Mq,Vq);
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOVSD(Vq,Wq);
                        0x1: MOVSD(Wq,Vq);
                        0x2: MOVDDUP(Vo,Wq);
                        default: UD2();
                    }
                    default: UD2();
                }
                0x03: decode OPCODE_OP_BOTTOM3 {
                    //group17();
                    0x0: decode MODRM_REG {
                        0x0: WarnUnimpl::prefetch_nta();
                        0x1: PREFETCH_T0(Mb);
                        0x2: WarnUnimpl::prefetch_t1();
                        0x3: WarnUnimpl::prefetch_t2();
                        default: HINT_NOP();
                    }
                    0x1: HINT_NOP();
                    0x2: HINT_NOP();
                    0x3: HINT_NOP();
                    0x4: HINT_NOP();
                    0x5: HINT_NOP();
                    0x6: HINT_NOP();
                    0x7: HINT_NOP();
                }
                0x04: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOV(Rd,Cd);
                        0x1: MOV(Rd,Dd);
                        0x2: MOV(Cd,Rd);
                        0x3: MOV(Dd,Rd);
                        0x4: WarnUnimpl::mov_Rd_Td();
                        0x6: WarnUnimpl::mov_Td_Rd();
                        default: UD2();
                    }
                    // lock prefix (0xF0)
                    0x2: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::mov_Rd_CR8D();
                        0x2: WarnUnimpl::mov_CR8D_Rd();
                    }
                    default: UD2();
                }
            }
            0x05: decode LEGACY_DECODEVAL {
                // no prefix
                0x0: decode OPCODE_OP_BOTTOM3 {
                    //These moves should really use size o (octword), but
                    //because they are split in two, they use q (quadword).
                    0x0: Inst::MOVAPS(Vq,Wq);
                    0x1: Inst::MOVAPS(Wq,Vq);
                    0x2: Inst::CVTPI2PS(Vq,Qq);
                    0x3: movntps_Mo_Vo();
                    0x4: cvttps2pi_Pq_Wq();
                    0x5: cvtpS2pi_Pq_Wq();
                    0x6: ucomiss_Vd_Wd();
                    0x7: comiss_Vd_Wd();
                }
                // repe (0xF3)
                0x4: decode OPCODE_OP_BOTTOM3 {
                    0x2: Inst::CVTSI2SS(Vd,Ed);
                    0x4: cvttss2si_Gd_Wd();
                    0x5: cvtss2si_Gd_Wd();
                    default: Inst::UD2();
                }
                // operand size (0x66)
                0x1: decode OPCODE_OP_BOTTOM3 {
                    0x0: Inst::MOVAPD(Vo,Wo);
                    0x1: Inst::MOVAPD(Wo,Vo);
                    0x2: Inst::CVTPI2PD(Vo,Qq);
                    0x3: movntpd_Mo_Vo();
                    0x4: cvttpd2pi_Pq_Wo();
                    0x5: cvtpd2pi_Pq_Wo();
                    0x6: Inst::UCOMISD(Vq,Wq);
                    0x7: comisd_Vq_Wq();
                }
                // repne (0xF2)
                0x8: decode OPCODE_OP_BOTTOM3 {
                    // The size of the V operand should be q, not dp
                    0x2: Inst::CVTSI2SD(Vdp,Edp);
                    // The size of the W operand should be q, not dp
                    0x4: Inst::CVTTSD2SI(Gdp,Wdp);
                    0x5: cvtsd2si_Gd_Wq();
                    default: Inst::UD2();
                }
                default: Inst::UD2();
            }
            0x06: decode OPCODE_OP_BOTTOM3 {
                0x0: Inst::WRMSR();
                0x1: Inst::RDTSC();
                0x2: Inst::RDMSR();
                0x3: rdpmc();
#if FULL_SYSTEM
                0x4: sysenter();
#else
                0x4: SyscallInst::sysenter('xc->syscall(Rax)', IsSyscall);
#endif
                0x5: sysexit();
                0x6: Inst::UD2();
                0x7: getsec();
            }
            0x07: decode OPCODE_OP_BOTTOM3 {
                0x0: three_byte_opcode();
                0x1: three_byte_opcode();
                0x2: three_byte_opcode();
                0x3: three_byte_opcode();
                0x4: three_byte_opcode();
                0x5: three_byte_opcode();
                0x6: three_byte_opcode();
                0x7: three_byte_opcode();
            }
            format Inst {
                0x08: decode OPCODE_OP_BOTTOM3 {
                    0x0: CMOVO(Gv,Ev);
                    0x1: CMOVNO(Gv,Ev);
                    0x2: CMOVB(Gv,Ev);
                    0x3: CMOVNB(Gv,Ev);
                    0x4: CMOVZ(Gv,Ev);
                    0x5: CMOVNZ(Gv,Ev);
                    0x6: CMOVBE(Gv,Ev);
                    0x7: CMOVNBE(Gv,Ev);
                }
                0x09: decode OPCODE_OP_BOTTOM3 {
                    0x0: CMOVS(Gv,Ev);
                    0x1: CMOVNS(Gv,Ev);
                    0x2: CMOVP(Gv,Ev);
                    0x3: CMOVNP(Gv,Ev);
                    0x4: CMOVL(Gv,Ev);
                    0x5: CMOVNL(Gv,Ev);
                    0x6: CMOVLE(Gv,Ev);
                    0x7: CMOVNLE(Gv,Ev);
                }
                0x0A: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOVMSKPS(Gd,VRo);
                        0x1: SQRTPS(Vo,Wo);
                        0x2: WarnUnimpl::rqsrtps_Vo_Wo();
                        0x3: WarnUnimpl::rcpps_Vo_Wo();
                        0x4: ANDPS(Vo,Wo);
                        0x5: ANDNPS(Vo,Wo);
                        0x6: ORPS(Vo,Wo);
                        0x7: XORPS(Vo,Wo);
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x1: SQRTSS(Vd,Wd);
                        0x2: WarnUnimpl::rsqrtss_Vd_Wd();
                        0x3: WarnUnimpl::rcpss_Vd_Wd();
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: MOVMSKPD(Gd,VRo);
                        0x1: SQRTPD(Vo,Wo);
                        0x4: ANDPD(Vo,Wo);
                        0x5: ANDNPD(Vo,Wo);
                        0x6: ORPD(Vo,Wo);
                        //This really should be type o, but it works on q sized
                        //chunks at a time.
                        0x7: XORPD(Vq,Wq);
                        default: UD2();
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x1: SQRTSD(Vq,Wq);
                        default: UD2();
                    }
                    default: UD2();
                }
                0x0B: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: ADDPS(Vo,Wo);
                        0x1: MULPS(Vo,Wo);
                        0x2: CVTPS2PD(Vo,Wq);
                        0x3: CVTDQ2PS(Vo,Wo);
                        0x4: SUBPS(Vo,Wo);
                        0x5: MINPS(Vo,Wo);
                        0x6: DIVPS(Vo,Wo);
                        0x7: MAXPS(Vo,Wo);
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x0: ADDSS(Vd,Wd);
                        0x1: MULSS(Vd,Wd);
                        0x2: CVTSS2SD(Vq,Wd);
                        0x3: WarnUnimpl::cvttps2dq_Vo_Wo();
                        0x4: SUBSS(Vd,Wd);
                        0x5: MINSS(Vd,Wd);
                        0x6: DIVSS(Vd,Wd);
                        0x7: MAXSS(Vd,Wd);
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: ADDPD(Vo,Wo);
                        0x1: MULPD(Vo,Wo);
                        0x2: CVTPD2PS(Vo,Wo);
                        0x3: WarnUnimpl::cvtps2dq_Vo_Wo();
                        0x4: SUBPD(Vo,Wo);
                        0x5: MINPD(Vo,Wo);
                        0x6: DIVPD(Vo,Wo);
                        0x7: MAXPD(Vo,Wo);
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x0: ADDSD(Vq,Wq);
                        0x1: MULSD(Vq,Wq);
                        0x2: CVTSD2SS(Vd,Wq);
                        0x4: SUBSD(Vq,Wq);
                        0x5: MINSD(Vq,Wq);
                        0x6: DIVSD(Vq,Wq);
                        0x7: MAXSD(Vq,Wq);
                        default: UD2();
                    }
                    default: UD2();
                }
                0x0C: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PUNPCKLBW(Pq,Qd);
                        0x1: PUNPCKLWD(Pq,Qd);
                        0x2: PUNPCKLDQ(Pq,Qd);
                        0x3: PACKSSWB(Pq,Qq);
                        0x4: PCMPGTB(Pq,Qq);
                        0x5: PCMPGTW(Pq,Qq);
                        0x6: PCMPGTD(Pq,Qq);
                        0x7: PACKUSWB(Pq,Qq);
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PUNPCKLBW(Vo,Wq);
                        0x1: PUNPCKLWD(Vo,Wq);
                        0x2: PUNPCKLDQ(Vo,Wq);
                        0x3: PACKSSWB(Vo,Wo);
                        0x4: PCMPGTB(Vo,Wo);
                        0x5: PCMPGTW(Vo,Wo);
                        0x6: PCMPGTD(Vo,Wo);
                        0x7: PACKUSWB(Vo,Wo);
                    }
                    default: UD2();
                }
                0x0D: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PUNPCKHBW(Pq,Qq);
                        0x1: PUNPCKHWD(Pq,Qq);
                        0x2: PUNPCKHDQ(Pq,Qq);
                        0x3: PACKSSDW(Pq,Qq);
                        0x6: MOVD(Pq,Edp);
                        0x7: MOVQ(Pq,Qq);
                        default: UD2();
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x7: WarnUnimpl::movdqu_Vo_Wo();
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PUNPCKHBW(Vo,Wo);
                        0x1: PUNPCKHWD(Vo,Wo);
                        0x2: PUNPCKHDQ(Vo,Wo);
                        0x3: PACKSSDW(Vo,Wo);
                        0x4: PUNPCKLQDQ(Vo,Wq);
                        0x5: PUNPCKHQDQ(Vo,Wq);
                        0x6: WarnUnimpl::movd_Vo_Ed();
                        0x7: WarnUnimpl::movdqa_Vo_Wo();
                    }
                    default: UD2();
                }
                0x0E: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSHUFW(Pq,Qq,Ib);
                        //0x1: group13_pshimw();
                        0x1: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLW(PRq,Ib);
                                0x1: PSRLW(VRo,Ib);
                            }
                            0x4: decode LEGACY_OP {
                                0x0: PSRAW(PRq,Ib);
                                0x1: PSRAW(VRo,Ib);
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLW(PRq,Ib);
                                0x1: PSLLW(VRo,Ib);
                            }
                            default: UD2();
                        }
                        //0x2: group14_pshimd();
                        0x2: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLD(PRq,Ib);
                                0x1: PSRLD(VRo,Ib);
                            }
                            0x4: decode LEGACY_OP {
                                0x0: PSRAD(PRq,Ib);
                                0x1: PSRAD(VRo,Ib);
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLD(PRq,Ib);
                                0x1: PSLLD(VRo,Ib);
                            }
                            default: UD2();
                        }
                        //0x3: group15_pshimq();
                        0x3: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLQ(PRq,Ib);
                                0x1: PSRLQ(VRo,Ib);
                            }
                            0x3: decode LEGACY_OP {
                                0x0: UD2();
                                0x1: WarnUnimpl::psrldq_VRo_Ib();
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLQ(PRq,Ib);
                                0x1: PSLLQ(VRo,Ib);
                            }
                            0x7: decode LEGACY_OP {
                                0x0: UD2();
                                0x1: WarnUnimpl::pslldq_VRo_Ib();
                            }
                            default: Inst::UD2();
                        }
                        0x4: Inst::PCMPEQB(Pq,Qq);
                        0x5: Inst::PCMPEQW(Pq,Qq);
                        0x6: Inst::PCMPEQD(Pq,Qq);
                        0x7: WarnUnimpl::emms();
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSHUFHW(Vo,Wo,Ib);
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSHUFD(Vo,Wo,Ib);
                        //0x1: group13_pshimw();
                        0x1: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLW(PRq,Ib);
                                0x1: PSRLW(VRo,Ib);
                            }
                            0x4: decode LEGACY_OP {
                                0x0: PSRAW(PRq,Ib);
                                0x1: PSRAW(VRo,Ib);
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLW(PRq,Ib);
                                0x1: PSLLW(VRo,Ib);
                            }
                            default: Inst::UD2();
                        }
                        //0x2: group14_pshimd();
                        0x2: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLD(PRq,Ib);
                                0x1: PSRLD(VRo,Ib);
                            }
                            0x4: decode LEGACY_OP {
                                0x0: PSRAD(PRq,Ib);
                                0x1: PSRAD(VRo,Ib);
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLD(PRq,Ib);
                                0x1: PSLLD(VRo,Ib);
                            }
                            default: UD2();
                        }
                        //0x3: group15_pshimq();
                        0x3: decode MODRM_REG {
                            0x2: decode LEGACY_OP {
                                0x0: PSRLQ(PRq,Ib);
                                0x1: PSRLQ(VRo,Ib);
                            }
                            0x3: decode LEGACY_OP {
                                0x0: UD2();
                                0x1: WarnUnimpl::psrldq_VRo_Ib();
                            }
                            0x6: decode LEGACY_OP {
                                0x0: PSLLQ(PRq,Ib);
                                0x1: PSLLQ(VRo,Ib);
                            }
                            0x7: decode LEGACY_OP {
                                0x0: UD2();
                                0x1: WarnUnimpl::pslldq_VRo_Ib();
                            }
                            default: UD2();
                        }
                        0x4: PCMPEQB(Vo,Wo);
                        0x5: PCMPEQW(Vo,Wo);
                        0x6: PCMPEQD(Vo,Wo);
                        default: UD2();
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSHUFLW(Vo,Wo,Ib);
                        default: UD2();
                    }
                    default: UD2();
                }
                0x0F: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::vmread_Ed_or_Eq_Gd_or_Gq();
                        0x1: WarnUnimpl::vmwrite_Gd_or_Gq_Ed_or_Eq();
                        0x6: MOVD(Edp,Pdp);
                        0x7: MOVQ(Qq,Pq);
                        default: UD2();
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x6: MOVQ(Vq,Wq);
                        0x7: WarnUnimpl::movdqu_Wo_Vo();
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x4: WarnUnimpl::haddpd_Vo_Wo();
                        0x5: WarnUnimpl::hsubpd_Vo_Wo();
                        0x6: WarnUnimpl::movd_Ed_Vd();
                        0x7: WarnUnimpl::movdqa_Wo_Vo();
                        default: UD2();
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x4: WarnUnimpl::haddps_Vo_Wo();
                        0x5: WarnUnimpl::hsubps_Vo_Wo();
                        default: UD2();
                    }
                    default: UD2();
                }
                0x10: decode OPCODE_OP_BOTTOM3 {
                    0x0: JO(Jz);
                    0x1: JNO(Jz);
                    0x2: JB(Jz);
                    0x3: JNB(Jz);
                    0x4: JZ(Jz);
                    0x5: JNZ(Jz);
                    0x6: JBE(Jz);
                    0x7: JNBE(Jz);
                }
                0x11: decode OPCODE_OP_BOTTOM3 {
                    0x0: JS(Jz);
                    0x1: JNS(Jz);
                    0x2: JP(Jz);
                    0x3: JNP(Jz);
                    0x4: JL(Jz);
                    0x5: JNL(Jz);
                    0x6: JLE(Jz);
                    0x7: JNLE(Jz);
                }
                0x12: decode OPCODE_OP_BOTTOM3 {
                    0x0: SETO(Eb);
                    0x1: SETNO(Eb);
                    0x2: SETB(Eb);
                    0x3: SETNB(Eb);
                    0x4: SETZ(Eb);
                    0x5: SETNZ(Eb);
                    0x6: SETBE(Eb);
                    0x7: SETNBE(Eb);
                }
                0x13: decode OPCODE_OP_BOTTOM3 {
                    0x0: SETS(Eb);
                    0x1: SETNS(Eb);
                    0x2: SETP(Eb);
                    0x3: SETNP(Eb);
                    0x4: SETL(Eb);
                    0x5: SETNL(Eb);
                    0x6: SETLE(Eb);
                    0x7: SETNLE(Eb);
                }
            }
            0x14: decode OPCODE_OP_BOTTOM3 {
                0x0: push_fs();
                0x1: pop_fs();
                0x2: CPUIDInst::CPUID({{
                    CpuidResult result;
                    success = doCpuid(xc->tcBase(), bits(Rax, 31, 0), result);
                    Rax = result.rax;
                    Rbx = result.rbx;
                    Rcx = result.rcx;
                    Rdx = result.rdx;
                    }});
                0x3: Inst::BT(Ev,Gv);
                0x4: Inst::SHLD(Ev,Gv,Ib);
                0x5: Inst::SHLD(Ev,Gv);
                0x6: xbts_and_cmpxchg();
                0x7: ibts_and_cmpxchg();
            }
            0x15: decode OPCODE_OP_BOTTOM3 {
                0x0: push_gs();
                0x1: pop_gs();
                0x2: rsm_smm();
                0x3: Inst::BTS(Ev,Gv);
                0x4: Inst::SHRD(Ev,Gv,Ib);
                0x5: Inst::SHRD(Ev,Gv);
                //0x6: group16();
                0x6: decode MODRM_REG {
                    0x0: fxsave();
                    0x1: fxrstor();
                    0x2: ldmxcsr();
                    0x3: stmxcsr();
                    0x4: Inst::UD2();
                    0x5: decode MODRM_MOD {
                        0x3: BasicOperate::LFENCE(
                                     {{/*Nothing*/}}, IsReadBarrier);
                        default: Inst::UD2();
                    }
                    0x6: decode MODRM_MOD {
                        0x3: BasicOperate::MFENCE(
                                     {{/*Nothing*/}}, IsMemBarrier);
                        default: Inst::UD2();
                    }
                    0x7: decode MODRM_MOD {
                        0x3: BasicOperate::SFENCE(
                                     {{/*Nothing*/}}, IsWriteBarrier);
                        default: Inst::UD2();
                    }
                }
                0x7: Inst::IMUL(Gv,Ev);
            }
            format Inst {
                0x16: decode OPCODE_OP_BOTTOM3 {
                    0x0: CMPXCHG(Eb,Gb);
                    0x1: CMPXCHG(Ev,Gv);
                    0x2: WarnUnimpl::lss_Gz_Mp();
                    0x3: BTR(Ev,Gv);
                    0x4: WarnUnimpl::lfs_Gz_Mp();
                    0x5: WarnUnimpl::lgs_Gz_Mp();
                    //The size of the second operand in these instructions
                    //should really be "b" or "w", but it's set to v in order
                    //to have a consistent register size. This shouldn't
                    //affect behavior.
                    0x6: MOVZX_B(Gv,Ev);
                    0x7: MOVZX_W(Gv,Ev);
                }
                0x17: decode OPCODE_OP_BOTTOM3 {
                    0x0: WarnUnimpl::jmpe_Jz(); // IA-64?
                    //0x1: group11_UD2();
                    0x1: UD2();
                    //0x2: group8_Ev_Ib();
                    0x2: decode MODRM_REG {
                        0x4: BT(Ev,Ib);
                        0x5: BTS(Ev,Ib);
                        0x6: BTR(Ev,Ib);
                        0x7: BTC(Ev,Ib);
                        default: UD2();
                    }
                    0x3: BTC(Ev,Gv);
                    0x4: BSF(Gv,Ev);
                    0x5: BSR(Gv,Ev);
                    //The size of the second operand in these instructions
                    //should really be "b" or "w", but it's set to v in order
                    //to have a consistent register size. This shouldn't
                    //affect behavior.
                    0x6: MOVSX_B(Gv,Ev);
                    0x7: MOVSX_W(Gv,Ev);
                }
                0x18: decode OPCODE_OP_BOTTOM3 {
                    0x0: XADD(Eb,Gb);
                    0x1: XADD(Ev,Gv);
                    //0x7: group9();
                    0x7: decode MODRM_REG {
                        //Also CMPXCHG16B
                        0x1: CMPXCHG8B(Mdp);
                        0x6: decode LEGACY_OP {
                            0x1: WarnUnimpl::vmclear_Mq();
                            default: decode LEGACY_REP {
                                0x1: WarnUnimpl::vmxon_Mq();
                                0x0: WarnUnimpl::vmptrld_Mq();
                            }
                        }
                        0x7: WarnUnimpl::vmptrst_Mq();
                        default: UD2();
                    }
                    default: decode LEGACY_DECODEVAL {
                        // no prefix
                        0x0: decode OPCODE_OP_BOTTOM3 {
                            0x2: WarnUnimpl::cmpccps_Vo_Wo_Ib();
                            0x3: WarnUnimpl::movnti_Mdq_Gdq();
                            0x4: PINSRW(Pq,Ew,Ib);
                            0x5: PEXTRW(Gd,PRq,Ib);
                            0x6: SHUFPS(Vps,Wps,Ib);
                        }
                        // repe (0xF3)
                        0x4: decode OPCODE_OP_BOTTOM3 {
                            0x2: WarnUnimpl::cmpccss_Vd_Wd_Ib();
                            default: UD2();
                        }
                        // operand size (0x66)
                        0x1: decode OPCODE_OP_BOTTOM3 {
                            0x2: WarnUnimpl::cmpccpd_Vo_Wo_Ib();
                            0x4: PINSRW(Vdw,Ew,Ib);
                            0x5: PEXTRW(Gd,VRdq,Ib);
                            0x6: SHUFPD(Vpd,Wpd,Ib);
                            default: UD2();
                        }
                        // repne (0xF2)
                        0x8: decode OPCODE_OP_BOTTOM3 {
                            0x2: WarnUnimpl::cmpccsd_Vq_Wq_Ib();
                            default: UD2();
                        }
                        default: UD2();
                    }
                }
                0x19: decode OPSIZE {
                    4: BSWAP_D(Bd);
                    8: BSWAP_Q(Bq);
                    default: UD2();
                }
                0x1A: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x1: PSRLW(Pq,Qq);
                        0x2: PSRLD(Pq,Qq);
                        0x3: PSRLQ(Pq,Qq);
                        0x4: PADDQ(Pq,Qq);
                        0x5: PMULLW(Pq,Qq);
                        0x7: PMOVMSKB(Gd,PRq);
                        default: UD2();
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x6: WarnUnimpl::movq2dq_Vo_PRq();
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::addsubpd_Vo_Wo();
                        0x1: PSRLW(Vo,Wo);
                        0x2: PSRLD(Vo,Wo);
                        0x3: PSRLQ(Vo,Wo);
                        0x4: PADDQ(Vo,Wo);
                        0x5: PMULLW(Vo,Wo);
                        0x6: MOVQ(Wq,Vq);
                        0x7: PMOVMSKB(Gd,VRo);
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::addsubps_Vo_Wo();
                        0x6: WarnUnimpl::movdq2q_Pq_VRq();
                        default: UD2();
                    }
                    default: UD2();
                }
                0x1B: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBUSB(Pq,Qq);
                        0x1: PSUBUSW(Pq,Qq);
                        0x2: PMINUB(Pq,Qq);
                        0x3: PAND(Pq,Qq);
                        0x4: PADDUSB(Pq,Qq);
                        0x5: PADDUSW(Pq,Qq);
                        0x6: PMAXUB(Pq,Qq);
                        0x7: PANDN(Pq,Qq);
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBUSB(Vo,Wo);
                        0x1: PSUBUSW(Vo,Wo);
                        0x2: PMINUB(Vo,Wo);
                        0x3: PAND(Vo,Wo);
                        0x4: PADDUSB(Vo,Wo);
                        0x5: PADDUSW(Vo,Wo);
                        0x6: PMAXUB(Vo,Wo);
                        0x7: PANDN(Vo,Wo);
                    }
                    default: UD2();
                }
                0x1C: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PAVGB(Pq,Qq);
                        0x1: PSRAW(Pq,Qq);
                        0x2: PSRAD(Pq,Qq);
                        0x3: PAVGW(Pq,Qq);
                        0x4: PMULHUW(Pq,Qq);
                        0x5: PMULHW(Pq,Qq);
                        0x7: WarnUnimpl::movntq_Mq_Pq();
                        default: UD2();
                    }
                    // repe (0xF3)
                    0x4: decode OPCODE_OP_BOTTOM3 {
                        0x6: CVTDQ2PD(Vo,Wq);
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PAVGB(Vo,Wo);
                        0x1: PSRAW(Vo,Wo);
                        0x2: PSRAD(Vo,Wo);
                        0x3: PAVGW(Vo,Wo);
                        0x4: PMULHUW(Vo,Wo);
                        0x5: PMULHW(Vo,Wo);
                        0x6: WarnUnimpl::cvttpd2dq_Vo_Wo();
                        0x7: WarnUnimpl::movntdq_Mo_Vo();
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x6: WarnUnimpl::cvtpd2dq_Vo_Wo();
                        default: UD2();
                    }
                    default: UD2();
                }
                0x1D: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBSB(Pq,Qq);
                        0x1: PSUBSW(Pq,Qq);
                        0x2: PMINSW(Pq,Qq);
                        0x3: POR(Pq,Qq);
                        0x4: PADDSB(Pq,Qq);
                        0x5: PADDSW(Pq,Qq);
                        0x6: PMAXSW(Pq,Qq);
                        0x7: PXOR(Pq,Qq);
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBSB(Vo,Wo);
                        0x1: PSUBSW(Vo,Wo);
                        0x2: PMINSW(Vo,Wo);
                        0x3: POR(Vo,Wo);
                        0x4: PADDSB(Vo,Wo);
                        0x5: PADDSW(Vo,Wo);
                        0x6: PMAXSW(Vo,Wo);
                        0x7: PXOR(Vo,Wo);
                    }
                    default: UD2();
                }
                0x1E: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x1: PSLLW(Pq,Qq);
                        0x2: PSLLD(Pq,Qq);
                        0x3: PSLLQ(Pq,Qq);
                        0x4: PMULUDQ(Pq,Qq);
                        0x5: PMADDWD(Pq,Qq);
                        0x6: PSADBW(Pq,Qq);
                        0x7: MASKMOVQ(Pq,PRq);
                        default: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x1: PSLLW(Vo,Wo);
                        0x2: PSLLD(Vo,Wo);
                        0x3: PSLLQ(Vo,Wo);
                        0x4: PMULUDQ(Vo,Wo);
                        0x5: PMADDWD(Vo,Wo);
                        0x6: PSADBW(Vo,Wo);
                        0x7: MASKMOVDQU(Vo,VRo);
                        default: UD2();
                    }
                    // repne (0xF2)
                    0x8: decode OPCODE_OP_BOTTOM3 {
                        0x0: WarnUnimpl::lddqu_Vo_Mo();
                        default: UD2();
                    }
                    default: UD2();
                }
                0x1F: decode LEGACY_DECODEVAL {
                    // no prefix
                    0x0: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBB(Pq,Qq);
                        0x1: PSUBW(Pq,Qq);
                        0x2: PSUBD(Pq,Qq);
                        0x3: PSUBQ(Pq,Qq);
                        0x4: PADDB(Pq,Qq);
                        0x5: PADDW(Pq,Qq);
                        0x6: PADDD(Pq,Qq);
                        0x7: UD2();
                    }
                    // operand size (0x66)
                    0x1: decode OPCODE_OP_BOTTOM3 {
                        0x0: PSUBB(Vo,Wo);
                        0x1: PSUBW(Vo,Wo);
                        0x2: PSUBD(Vo,Wo);
                        0x3: PSUBQ(Vo,Wo);
                        0x4: PADDB(Vo,Wo);
                        0x5: PADDW(Vo,Wo);
                        0x6: PADDD(Vo,Wo);
                        0x7: UD2();
                    }
                    default: UD2();
                }
            }
            default: FailUnimpl::twoByteOps();
        }
    }
    default: M5InternalError::error(
        {{"Unexpected first opcode byte in two byte opcode!"}});
}
